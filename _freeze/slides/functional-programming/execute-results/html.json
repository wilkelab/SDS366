{
  "hash": "fce4a932dc38b28839ca2b36f628f1d8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functions and functional programming\"\nauthor: \"Claus O. Wilke\"\ndate: last-modified\nformat: \n  revealjs:\n    theme:\n      - default\n      - Wilke-theme.scss\n    auto-stretch: false\n    chalkboard: true\nexecute:\n  fig-format: svg\n  fig-asp: 0.618\n  fig-width: 5.5\n---\n\n\n\n\n\n## We often have to run similar code multiple times\n\n::: {.fragment .tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\npenguins |>\n  filter(species == \"Adelie\") |>\n  ggplot() +\n  aes(bill_length_mm, body_mass_g) +\n  geom_point() +\n  ggtitle(\"Species: Adelie\") +\n  xlab(\"bill length (mm)\") +\n  ylab(\"body mass (g)\") +\n  theme_minimal_grid() +\n  theme(plot.title.position = \"plot\")\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-Adelie-1.svg){width=100%}\n:::\n:::\n\n\n:::\n\n\n## We often have to run similar code multiple times\n\n::: {.tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\npenguins |>\n  filter(species == \"Chinstrap\") |>\n  ggplot() +\n  aes(bill_length_mm, body_mass_g) +\n  geom_point() +\n  ggtitle(\"Species: Chinstrap\") +\n  xlab(\"bill length (mm)\") +\n  ylab(\"body mass (g)\") +\n  theme_minimal_grid() +\n  theme(plot.title.position = \"plot\")\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-Chinstrap-1.svg){width=100%}\n:::\n:::\n\n\n:::\n\n\n## We often have to run similar code multiple times\n\n::: {.tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\npenguins |>\n  filter(species == \"Gentoo\") |>\n  ggplot() +\n  aes(bill_length_mm, body_mass_g) +\n  geom_point() +\n  ggtitle(\"Species: Gentoo\") +\n  xlab(\"bill length (mm)\") +\n  ylab(\"body mass (g)\") +\n  theme_minimal_grid() +\n  theme(plot.title.position = \"plot\")\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-Gentoo-1.svg){width=100%}\n:::\n:::\n\n\n:::\n\n::: {.fragment .small-font}\nHow can we make our life simpler and avoid massive code duplication?\n:::\n\n## Step 1: Avoid hard-coding specific values\n\n::: {.fragment .tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code  code-line-numbers=\"1,4,8\"}\nspecies <- \"Adelie\"\n\npenguins |>\n  filter(.data$species == .env$species) |>\n  ggplot() +\n  aes(bill_length_mm, body_mass_g) +\n  geom_point() +\n  ggtitle(glue(\"Species: {species}\")) +\n  xlab(\"bill length (mm)\") +\n  ylab(\"body mass (g)\") +\n  theme_minimal_grid() +\n  theme(plot.title.position = \"plot\")\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-Adelie2-1.svg){width=100%}\n:::\n:::\n\n\n:::\n\n## A quick aside: the pronouns `.data` and `.env`\n\n::: {.fragment .small-font}\nWe can use pronouns to distinguish data columns from variables:\n```r\nspecies <- \"Adelie\"\n\npenguins |>\n  filter(.data$species == .env$species)\n```\n:::\n\n::: {.fragment .small-font}\n`.data$species` is a column in the data frame\n:::\n\n::: {.fragment .small-font}\n`.env$species` is a variable in the local environment\n:::\n\n::: {.fragment .small-font}\nAlternatively we would have to make sure the names don't clash:\n\n```r\nspecies_choice <- \"Adelie\"\n\npenguins |>\n  filter(species == species_choice)\n```\n:::\n\n## Step 1: Avoid hard-coding specific values\n\n::: {.tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code  code-line-numbers=\"1-1\"}\nspecies <- \"Adelie\"\n\npenguins |>\n  filter(.data$species == .env$species) |>\n  ggplot() +\n  aes(bill_length_mm, body_mass_g) +\n  geom_point() +\n  ggtitle(glue(\"Species: {species}\")) +\n  xlab(\"bill length (mm)\") +\n  ylab(\"body mass (g)\") +\n  theme_minimal_grid() +\n  theme(plot.title.position = \"plot\")\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-Adelie2a-1.svg){width=100%}\n:::\n:::\n\n\n:::\n\n## Step 1: Avoid hard-coding specific values\n\n::: {.tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code  code-line-numbers=\"1-1\"}\nspecies <- \"Chinstrap\"\n\npenguins |>\n  filter(.data$species == .env$species) |>\n  ggplot() +\n  aes(bill_length_mm, body_mass_g) +\n  geom_point() +\n  ggtitle(glue(\"Species: {species}\")) +\n  xlab(\"bill length (mm)\") +\n  ylab(\"body mass (g)\") +\n  theme_minimal_grid() +\n  theme(plot.title.position = \"plot\")\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-Chinstrap2-1.svg){width=100%}\n:::\n:::\n\n\n:::\n\n## Step 1: Avoid hard-coding specific values\n\n::: {.tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code  code-line-numbers=\"1-1\"}\nspecies <- \"Gentoo\"\n\npenguins |>\n  filter(.data$species == .env$species) |>\n  ggplot() +\n  aes(bill_length_mm, body_mass_g) +\n  geom_point() +\n  ggtitle(glue(\"Species: {species}\")) +\n  xlab(\"bill length (mm)\") +\n  ylab(\"body mass (g)\") +\n  theme_minimal_grid() +\n  theme(plot.title.position = \"plot\")\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-Gentoo2-1.svg){width=100%}\n:::\n:::\n\n\n:::\n\n::: {.fragment .small-font}\nThis concept is also called: Avoiding magic numbers\n:::\n\n## Step 2: Define a function\n\n::: {.fragment .tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code  code-line-numbers=\"1,12\"}\nmake_plot <- function(species) {\n  penguins |>\n    filter(.data$species == .env$species) |>\n    ggplot() +\n    aes(bill_length_mm, body_mass_g) +\n    geom_point() +\n    ggtitle(glue(\"Species: {species}\")) +\n    xlab(\"bill length (mm)\") +\n    ylab(\"body mass (g)\") +\n    theme_minimal_grid() +\n    theme(plot.title.position = \"plot\")\n}\n```\n:::\n\n\n:::\n\n## Step 2: Define a function\n\n::: {.tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code  code-line-numbers=\"14-14\"}\nmake_plot <- function(species) {\n  penguins |>\n    filter(.data$species == .env$species) |>\n    ggplot() +\n    aes(bill_length_mm, body_mass_g) +\n    geom_point() +\n    ggtitle(glue(\"Species: {species}\")) +\n    xlab(\"bill length (mm)\") +\n    ylab(\"body mass (g)\") +\n    theme_minimal_grid() +\n    theme(plot.title.position = \"plot\")\n}\n\nmake_plot(\"Adelie\")\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-Adelie3-1.svg){width=100%}\n:::\n:::\n\n\n:::\n\n## Step 2: Define a function\n\n::: {.tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\nmake_plot(\"Adelie\")\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-all-1.svg){width=100%}\n:::\n\n```{.r .cell-code}\nmake_plot(\"Chinstrap\")\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-all-2.svg){width=100%}\n:::\n\n```{.r .cell-code}\nmake_plot(\"Gentoo\")\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-all-3.svg){width=100%}\n:::\n:::\n\n\n:::\n\n## Rules of thumb about functions\n\n::: {.fragment .small-font}\n- You can never write too many functions\n:::\n\n::: {.fragment .small-font}\n- When you find yourself writing the same code 2-3 times, put it into a function\n:::\n\n::: {.fragment .small-font}\n- A function should be no longer than 20-40 lines\n:::\n\n::: {.fragment .small-font}\n- If a function is getting too long, break it into smaller functions\n:::\n\n\n## Step 3: Automate calling the function\n\n::: {.fragment .small-font}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies <- c(\"Adelie\", \"Chinstrap\", \"Gentoo\")\nplots <- map(species, make_plot)\n```\n:::\n\n\n:::\n\n::: {.fragment .small-font}\n`map` takes each element of the vector `species` and uses it as input for `make_plot()`\n:::\n\n::: {.fragment .small-font}\nIt returns a list of created plots:\n\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\nplots[[1]]\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-map-return-1.svg){fig-align='left' width=32%}\n:::\n:::\n\n\n:::\n\n## Step 3: Automate calling the function\n\n::: {.small-font}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies <- c(\"Adelie\", \"Chinstrap\", \"Gentoo\")\nplots <- map(species, make_plot)\n```\n:::\n\n\n:::\n\n::: {.small-font}\n`map` takes each element of the vector `species` and uses it as input for `make_plot()`\n:::\n\n::: {.small-font}\nIt returns a list of created plots:\n\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\nplots[[2]]\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-map-return2-1.svg){fig-align='left' width=32%}\n:::\n:::\n\n\n:::\n\n## Step 3: Automate calling the function\n\n::: {.small-font}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies <- c(\"Adelie\", \"Chinstrap\", \"Gentoo\")\nplots <- map(species, make_plot)\n```\n:::\n\n\n:::\n\n::: {.small-font}\n`map` takes each element of the vector `species` and uses it as input for `make_plot()`\n:::\n\n::: {.small-font}\nIt returns a list of created plots:\n\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\nplots[[3]]\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-map-return3-1.svg){fig-align='left' width=32%}\n:::\n:::\n\n\n:::\n\n## Step 3: Automate calling the function\n\n::: {.small-font}\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\nspecies <- c(\"Adelie\", \"Chinstrap\", \"Gentoo\")\nplots <- map(species, make_plot)\n\n# put all plots side-by-side with patchwork\npatchwork::wrap_plots(plots)\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-map-1.svg){fig-align='left' width=100%}\n:::\n:::\n\n\n:::\n\n## Step 4: Write a more general function\n\n::: {.fragment .tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code  code-line-numbers=\"2-2\"}\nmake_plot <- function(species) {\n  penguins |> # hard-coded dataset!\n    filter(.data$species == .env$species) |>\n    ggplot() +\n    aes(bill_length_mm, body_mass_g) +\n    geom_point() +\n    ggtitle(glue(\"Species: {species}\")) +\n    xlab(\"bill length (mm)\") +\n    ylab(\"body mass (g)\") +\n    theme_minimal_grid() +\n    theme(plot.title.position = \"plot\")\n}\n```\n:::\n\n\n:::\n\n## Step 4: Write a more general function\n\n::: {.tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code  code-line-numbers=\"1-3\"}\nmake_plot2 <- function(data, species) {\n  data |>\n    # filter no longer needed\n    ggplot() +\n    aes(bill_length_mm, body_mass_g) +\n    geom_point() +\n    ggtitle(glue(\"Species: {species}\")) +\n    xlab(\"bill length (mm)\") +\n    ylab(\"body mass (g)\") +\n    theme_minimal_grid() +\n    theme(plot.title.position = \"plot\")\n}\n```\n:::\n\n\n:::\n\n## Step 4: Write a more general function\n\n::: {.tiny-font .move-down-1em}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\nmake_plot2 <- function(data, species) {\n  data |>\n    # filter no longer needed\n    ggplot() +\n    aes(bill_length_mm, body_mass_g) +\n    geom_point() +\n    ggtitle(glue(\"Species: {species}\")) +\n    xlab(\"bill length (mm)\") +\n    ylab(\"body mass (g)\") +\n    theme_minimal_grid() +\n    theme(plot.title.position = \"plot\")\n}\n\ndata_adelie <- penguins |>\n  filter(species == \"Adelie\")\n\nmake_plot2(data_adelie, species = \"Adelie\")\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/unnamed-chunk-21-1.svg){width=100%}\n:::\n:::\n\n\n:::\n\n## Step 5: Use these concepts in a tidy pipeline\n\n::: {.tiny-font .move-down-1em}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  nest(data = -species) |>\n  mutate(plots = map(species, make_plot))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  species   data               plots \n  <fct>     <list>             <list>\n1 Adelie    <tibble [152 × 7]> <gg>  \n2 Gentoo    <tibble [124 × 7]> <gg>  \n3 Chinstrap <tibble [68 × 7]>  <gg>  \n```\n\n\n:::\n:::\n\n\n:::\n\n## Step 5: Use these concepts in a tidy pipeline\n\n::: {.tiny-font}\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\npenguins |>\n  nest(data = -species) |>\n  mutate(plots = map(species, make_plot)) |>\n  pull(plots) |>\n  patchwork::wrap_plots()\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-tidy-1.svg){fig-align='left' width=100%}\n:::\n:::\n\n\n:::\n\n## Step 5: Use these concepts in a tidy pipeline\n\n::: {.tiny-font}\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\npenguins |>\n  nest(data = -species) |>\n  mutate(plots = map2(data, species, make_plot2)) |>\n  pull(plots) |>\n  patchwork::wrap_plots()\n```\n\n::: {.cell-output-display}\n![&nbsp;](functional-programming_files/figure-revealjs/penguins-plot-tidy2-1.svg){fig-align='left' width=100%}\n:::\n:::\n\n\n:::\n\n::: {.fragment .small-font}\n`map2()` is like `map()` but for functions with 2 arguments\n:::\n\n::: {.fragment .small-font}\nNote: This pipeline automatically processes all species in the dataset, whatever they are called\n:::\n\n## Why no `for` loops?\n\n::: {.fragment .small-font}\n- They often require us to think about data logistics (indexing)\n:::\n\n::: {.fragment .small-font}\n- They encourage writing long, monolithic blocks of code\n:::\n\n::: {.fragment .small-font}\n- They encourage iterative thinking over conceptual thinking\n:::\n\n::: {.fragment .small-font}\n- They cannot easily be parallelized or otherwise optimized\n:::\n\n::: {.fragment .small-font}\n- Most modern programming languages are moving away from `for` loops<br>\n  (examples: Python, Rust, JavaScript)\n:::\n\n<!-- Segment ends here -->\n\n## Further reading\n\n- R for Data Science: [Chapter 19: Functions](https://r4ds.had.co.nz/functions.html)\n- R for Data Science: [Chapter 21.5: The map functions](https://r4ds.had.co.nz/iteration.html#the-map-functions)\n- **purrr** reference documentation: [Apply a function to each element of a list or atomic vector](https://purrr.tidyverse.org/reference/map.html)\n\n",
    "supporting": [
      "functional-programming_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}