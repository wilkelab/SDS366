{
  "hash": "4b9108ac19f099ee2a473e0bafd16eb4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Working with models\"\nauthor: \"Claus O. Wilke\"\nformat: live-html\nengine: knitr\nwebr:\n  render-df: paged-table\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Introduction\n\nIn this worksheet, we will discuss how to efficiently fit statistical models (such as linear regressions) to subsets of data and then use for plotting.\n\nFirst we need to load the required R packages. Please wait a moment until the live R session is fully set up and all packages are loaded.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| warning: false\n#| edit: false\nlibrary(tidyverse)\nlibrary(palmerpenguins)\nlibrary(broom)\nlibrary(glue)\n```\n:::\n\n\n\n\nNext we set up the data. We will be working with data on individual penguins in Antarctica.\n```r\npenguins\n```\n\n::: {.column-page}\n\n\n\n::: {.cell}\n```{webr}\n#| echo: false\npenguins\n```\n:::\n\n\n\n:::\n\n## Inserting data into text output\n\nThere are several utility functions we need to understand before we can fit models, process them with **broom**, and ultimately plot. These include nesting and unnesting of data tables, using `map()` to apply a function to all the values in a data column, and using `glue()` to generate generate text. We have discussed nesting/unnesting and `map()` in the lecture on functional programming, and you may want to review this material if it is unclear to you. Here, we will discuss how to insert data into text output.\n\nThe `glue()` function allows you to place variables into a text string. This is frequently useful when we want to process multiple subsets of a larger data table and generate output for each subset.\n\nFor example:\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\ndog <- \"Buddy\"\nglue(\"I have a dog named {dog}.\")\n```\n:::\n\n\n\n\nThis also works for vectorized input.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npet <- c(\"dog\", \"dog\", \"cat\")\npet_name <- c(\"Buddy\", \"Lucy\", \"Oscar\")\nglue(\"I have a {pet} named {pet_name}.\")\n```\n:::\n\n\n\n\nTry this for yourself. Create variables holding your first and last name and then print out your complete name using `glue()`.\n\n\n\n\n::: {.cell exercise='glue-exercise'}\n```{webr}\n#| exercise: glue-exercise\nfirst_name <- ___\nlast_name <- ___\n\nglue(\"My name is ___.\")\n```\n:::\n\n\n\n\n::: { .hint exercise=\"glue-exercise\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nfirst_name <- \"Claus\"\nlast_name <- \"Wilke\"\n\nglue(\"My name is ___.\")\n```\n:::\n:::\n\n::: { .solution exercise=\"glue-exercise\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nfirst_name <- \"Claus\"\nlast_name <- \"Wilke\"\n\nglue(\"My name is {first_name} {last_name}.\")\n```\n:::\n:::\n\n## Cleaning up models with **broom**\n\nR has powerful functions to fit statistical models to data, such as `lm()` to fit linear regression models. However, many of these functions have been written for interactive use and don't work well in an automated data processing pipeline. For example, consider the following code to perform a linear regression analysis on the penguins dataset (ignoring for a moment that there are multiple species):\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nfit <- lm(bill_length_mm ~ body_mass_g, data = penguins)\nfit\nsummary(fit)\n```\n:::\n\n\n\n\nThe `fit` object stores information about the linear regression, and `summary(fit)` shows us this information in a nice, human-readable form. But what if we want the relevant information in a data table? This is where the **broom** package comes in. The `glance()` function extracts model-level summary data from a fitted object, and the `tidy()` function extracts information about individual regression coefficients.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nglance(fit)\ntidy(fit)\n```\n:::\n\n\n\n\nTry this yourself. Fit a model of bill length versus bill depth (formula: `bill_length_mm ~ bill_depth_mm`), look at the model fit with `summary()`, and then look at the model fit via `glance()` and `tidy()`.\n\n\n\n\n::: {.cell exercise='glance-tidy'}\n```{webr}\n#| exercise: glance-tidy\n# fit linear model\nfit <- lm(___)\n\n# inspect model fit with summary()\n\n# inspect model fit with glance() and tidy()\n```\n:::\n\n\n\n\n::: { .hint exercise=\"glance-tidy\" }\n::: { .callout-tip title=\"Hint 1\" collapse=\"false\"}\n```r\n# fit linear model\nfit <- lm(bill_length_mm ~ bill_depth_mm, data = penguins)\n\n# inspect model fit with summary()\nsummary(___)\n\n# inspect model fit with glance() and tidy()\n```\n:::\n:::\n\n::: { .hint exercise=\"glance-tidy\" }\n::: { .callout-tip title=\"Hint 2\" collapse=\"false\"}\n```r\n# fit linear model\nfit <- lm(bill_length_mm ~ bill_depth_mm, data = penguins)\n\n# inspect model fit with summary()\nsummary(fit)\n\n# inspect model fit with glance() and tidy()\nglance(___)\ntidy(___)\n```\n:::\n:::\n\n::: { .solution exercise=\"glance-tidy\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\n# fit linear model\nfit <- lm(bill_length_mm ~ bill_depth_mm, data = penguins)\n\n# inspect model fit with summary()\nsummary(fit)\n\n# inspect model fit with glance() and tidy()\nglance(fit)\ntidy(fit)\n```\n:::\n:::\n\nThe real power of `glance()` and `tidy()` becomes apparent in a more complex data analysis pipeline, when we fit a model to subsets of data via `map()` and then combine the results from the individual fits into one large table.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins |>\n  nest(data = -species) |>     # nest the data table by species\n  mutate(\n    # use map() to fit a model to each nested data table\n    fit = map(data, ~lm(bill_length_mm ~ body_mass_g, data = .x)),\n    # use map to apply glance() to each model fit\n    glance_out = map(fit, glance)\n  ) |>\n  unnest(cols = glance_out) |> # unnest output from glance\n  select(-data, -fit)          # remove columns data and fit\n```\n:::\n\n\n\n\nNow run this code yourself one line at a time and make sure you understand at each step what is happening. Review the materials from the class on functional programming if anything is unclear. Note: The individual stages of the calculation are provided as hints, so you can just click through the hints one-by-one and run each piece.\n\n\n\n\n::: {.cell exercise='broom-map'}\n```{webr}\n#| exercise: broom-map\npenguins |>\n  nest(data = -species)         # nest the data table by species\n```\n:::\n\n\n\n\n::: { .hint exercise=\"broom-map\" }\n::: { .callout-tip title=\"Hint 1\" collapse=\"false\"}\n```r\npenguins |>\n  nest(data = -species) |>     # nest the data table by species\n  mutate(\n    # use map() to fit a model to each nested data table\n    fit = map(data, ~lm(bill_length_mm ~ body_mass_g, data = .x))\n  )\n```\n:::\n:::\n\n::: { .hint exercise=\"broom-map\" }\n::: { .callout-tip title=\"Hint 2\" collapse=\"false\"}\n```r\npenguins |>\n  nest(data = -species) |>     # nest the data table by species\n  mutate(\n    # use map() to fit a model to each nested data table\n    fit = map(data, ~lm(bill_length_mm ~ body_mass_g, data = .x)),\n    # use map to apply glance() to each model fit\n    glance_out = map(fit, glance)\n  )\n```\n:::\n:::\n\n::: { .hint exercise=\"broom-map\" }\n::: { .callout-tip title=\"Hint 3\" collapse=\"false\"}\n```r\npenguins |>\n  nest(data = -species) |>     # nest the data table by species\n  mutate(\n    # use map() to fit a model to each nested data table\n    fit = map(data, ~lm(bill_length_mm ~ body_mass_g, data = .x)),\n    # use map to apply glance() to each model fit\n    glance_out = map(fit, glance)\n  ) |>\n  unnest(cols = glance_out)     # unnest output from glance\n```\n:::\n:::\n\n::: { .solution exercise=\"broom-map\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  nest(data = -species) |>     # nest the data table by species\n  mutate(\n    # use map() to fit a model to each nested data table\n    fit = map(data, ~lm(bill_length_mm ~ body_mass_g, data = .x)),\n    # use map to apply glance() to each model fit\n    glance_out = map(fit, glance)\n  ) |>\n  unnest(cols = glance_out) |> # unnest output from glance\n  select(-data, -fit)           # remove columns data and fit\n```\n:::\n:::\n\n## Plotting model fits\n\n**still to do...**",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}