{
  "hash": "28e1589901375769c8fae946024050e3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Working with models\"\nauthor: \"Claus O. Wilke\"\nformat: live-html\nengine: knitr\nwebr:\n  render-df: paged-table\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Introduction\n\nIn this worksheet, we will discuss how to efficiently fit statistical models (such as linear regressions) to subsets of data and then use for plotting.\n\nFirst we need to load the required R packages. Please wait a moment until the live R session is fully set up and all packages are loaded.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| warning: false\n#| edit: false\nlibrary(tidyverse)\nlibrary(palmerpenguins)\nlibrary(broom)\nlibrary(glue)\n```\n:::\n\n\n\n\nNext we set up the data. We will be working with data on individual penguins in Antarctica.\n\n\n\n::: {.cell}\n```{webr}\n#| echo: false\npenguins\n```\n:::\n\n\n\n\n## Inserting data into text output\n\nThere are several utility functions we need to understand before we can fit models, process them with **broom**, and ultimately plot. These include nesting and unnesting of data tables, using `map()` to apply a function to all the values in a data column, and using `glue()` to generate generate text. We have discussed nesting/unnesting and `map()` in the lecture on functional programming, and you may want to review this material if it is unclear to you. Here, we will discuss how to insert data into text output.\n\nThe `glue()` function allows you to place variables into a text string. This is frequently useful when we want to process multiple subsets of a larger data table and generate output for each subset.\n\nFor example:\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\ndog <- \"Buddy\"\nglue(\"I have a dog named {dog}.\")\n```\n:::\n\n\n\n\nThis also works for vectorized input.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npet <- c(\"dog\", \"dog\", \"cat\")\npet_name <- c(\"Buddy\", \"Lucy\", \"Oscar\")\nglue(\"I have a {pet} named {pet_name}.\")\n```\n:::\n\n\n\n\nTry this for yourself. Create variables holding your first and last name and then print out your complete name using `glue()`.\n\n\n\n\n::: {.cell exercise='glue-exercise'}\n```{webr}\n#| exercise: glue-exercise\nfirst_name <- ___\nlast_name <- ___\n\nglue(\"My name is ___.\")\n```\n:::\n\n\n\n\n::: { .hint exercise=\"glue-exercise\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nfirst_name <- \"Claus\"\nlast_name <- \"Wilke\"\n\nglue(\"My name is ___.\")\n```\n:::\n:::\n\n::: { .solution exercise=\"glue-exercise\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nfirst_name <- \"Claus\"\nlast_name <- \"Wilke\"\n\nglue(\"My name is {first_name} {last_name}.\")\n```\n:::\n:::\n\n## Cleaning up models with **broom**\n\nR has powerful functions to fit statistical models to data, such as `lm()` to fit linear regression models. However, many of these functions have been written for interactive use and don't work well in an automated data processing pipeline. For example, consider the following code to perform a linear regression analysis on the penguins dataset (ignoring for a moment that there are multiple species):\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nfit <- lm(bill_length_mm ~ body_mass_g, data = penguins)\nfit\nsummary(fit)\n```\n:::\n\n\n\n\nThe `fit` object stores information about the linear regression, and `summary(fit)` shows us this information in a nice, human-readable form. But what if we want the relevant information in a data table? This is where the **broom** package comes in. The `glance()` function extracts model-level summary data from a fitted object, and the `tidy()` function extracts information about individual regression coefficients.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nglance(fit)\ntidy(fit)\n```\n:::\n\n\n\n\nTry this yourself. Fit a model of bill length versus bill depth (formula: `bill_length_mm ~ bill_depth_mm`), look at the model fit with `summary()`, and then look at the model fit via `glance()` and `tidy()`.\n\n\n\n\n::: {.cell exercise='glance-tidy'}\n```{webr}\n#| exercise: glance-tidy\n# fit linear model\nfit <- lm(___)\n\n# inspect model fit with summary()\n\n# inspect model fit with glance() and tidy()\n```\n:::\n\n\n\n\n::: { .hint exercise=\"glance-tidy\" }\n::: { .callout-tip title=\"Hint 1\" collapse=\"false\"}\n```r\n# fit linear model\nfit <- lm(bill_length_mm ~ bill_depth_mm, data = penguins)\n\n# inspect model fit with summary()\nsummary(___)\n\n# inspect model fit with glance() and tidy()\n```\n:::\n:::\n\n::: { .hint exercise=\"glance-tidy\" }\n::: { .callout-tip title=\"Hint 2\" collapse=\"false\"}\n```r\n# fit linear model\nfit <- lm(bill_length_mm ~ bill_depth_mm, data = penguins)\n\n# inspect model fit with summary()\nsummary(fit)\n\n# inspect model fit with glance() and tidy()\nglance(___)\ntidy(___)\n```\n:::\n:::\n\n::: { .solution exercise=\"glance-tidy\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\n# fit linear model\nfit <- lm(bill_length_mm ~ bill_depth_mm, data = penguins)\n\n# inspect model fit with summary()\nsummary(fit)\n\n# inspect model fit with glance() and tidy()\nglance(fit)\ntidy(fit)\n```\n:::\n:::\n\nThe real power of `glance()` and `tidy()` becomes apparent in a more complex data analysis pipeline, when we fit a model to subsets of data via `map()` and then combine the results from the individual fits into one large table.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins |>\n  nest(data = -species) |>     # nest the data table by species\n  mutate(\n    # use map() to fit a model to each nested data table\n    fit = map(data, ~lm(bill_length_mm ~ body_mass_g, data = .x)),\n    # use map to apply glance() to each model fit\n    glance_out = map(fit, glance)\n  ) |>\n  unnest(cols = glance_out) |> # unnest output from glance\n  select(-data, -fit)          # remove columns data and fit\n```\n:::\n\n\n\n\nNow run this code yourself one line at a time and make sure you understand at each step what is happening. Review the materials from the class on functional programming if anything is unclear. Note: The individual stages of the calculation are provided as hints, so you can just click through the hints one-by-one and run each piece.\n\n\n\n\n::: {.cell exercise='broom-map'}\n```{webr}\n#| exercise: broom-map\npenguins |>\n  nest(data = -species)         # nest the data table by species\n```\n:::\n\n\n\n\n::: { .hint exercise=\"broom-map\" }\n::: { .callout-tip title=\"Hint 1\" collapse=\"false\"}\n```r\npenguins |>\n  nest(data = -species) |>     # nest the data table by species\n  mutate(\n    # use map() to fit a model to each nested data table\n    fit = map(data, ~lm(bill_length_mm ~ body_mass_g, data = .x))\n  )\n```\n:::\n:::\n\n::: { .hint exercise=\"broom-map\" }\n::: { .callout-tip title=\"Hint 2\" collapse=\"false\"}\n```r\npenguins |>\n  nest(data = -species) |>     # nest the data table by species\n  mutate(\n    # use map() to fit a model to each nested data table\n    fit = map(data, ~lm(bill_length_mm ~ body_mass_g, data = .x)),\n    # use map to apply glance() to each model fit\n    glance_out = map(fit, glance)\n  )\n```\n:::\n:::\n\n::: { .hint exercise=\"broom-map\" }\n::: { .callout-tip title=\"Hint 3\" collapse=\"false\"}\n```r\npenguins |>\n  nest(data = -species) |>     # nest the data table by species\n  mutate(\n    # use map() to fit a model to each nested data table\n    fit = map(data, ~lm(bill_length_mm ~ body_mass_g, data = .x)),\n    # use map to apply glance() to each model fit\n    glance_out = map(fit, glance)\n  ) |>\n  unnest(cols = glance_out)     # unnest output from glance\n```\n:::\n:::\n\n::: { .solution exercise=\"broom-map\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  nest(data = -species) |>     # nest the data table by species\n  mutate(\n    # use map() to fit a model to each nested data table\n    fit = map(data, ~lm(bill_length_mm ~ body_mass_g, data = .x)),\n    # use map to apply glance() to each model fit\n    glance_out = map(fit, glance)\n  ) |>\n  unnest(cols = glance_out) |> # unnest output from glance\n  select(-data, -fit)           # remove columns data and fit\n```\n:::\n:::\n\n## Plotting model fits\n\nFinally, we use the results from the model fit to plot a *p* value on each facet of a regression plot. The plot we'll be working with is the following:\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| fig-width: 8\n#| fig-height: 4\n#| message: false\nggplot(penguins, aes(body_mass_g, bill_length_mm)) +\n  geom_point(na.rm = TRUE) +\n  geom_smooth(method = \"lm\", formula = y ~ x, na.rm = TRUE) +\n  facet_wrap(~species)\n```\n:::\n\n\n\n\nWe can generate the fitted models as in the previous section. We will store them in the `penguins_fits`:\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins_fits <- penguins |>\n  nest(data = -species) |>     # nest the data table by species\n  mutate(\n    # use map() to fit a model to each nested data table\n    fit = map(data, ~lm(bill_length_mm ~ body_mass_g, data = .x)),\n    # use map to apply glance() to each model fit\n    glance_out = map(fit, glance)\n  ) |>\n  unnest(cols = glance_out) |> # unnest output from glance\n  select(-data, -fit)          # remove columns data and fit\n\npenguins_fits\n```\n:::\n\n\n\n\nNow, do the following. First, use `mutate()`, `glue()`, and `select()` to convert this table into one that has four columns, `species`, `body_mass_g`, `bill_length_mm`, and `label`. The `species` column holds the penguin species. The next two columns will hold the coordinates of the text label. For example, the values `body_mass_g = 5500` and `bill_length_mm = 32` will work. The last column will hold labels, generated with `glue()`, of the form \"p = 7.48e-06\". You can use `signif(p.value, 3)` to round *p* values to three significant digits.\n\nOnce you have this table, use `geom_text()` to add the labels to the above plot.\n\n\n\n\n::: {.cell exercise='regression-plot-exercise'}\n```{webr}\n#| exercise: regression-plot-exercise\n#| fig-width: 8\n#| fig-height: 4\n# first do the data table manipulation\nlabels_data <- penguins_fits |>\n  mutate(\n    ___\n  )\nlabels_data\n  \n# then plot\n```\n:::\n\n\n\n\n::: { .hint exercise=\"regression-plot-exercise\" }\n::: { .callout-tip title=\"Hint 1\" collapse=\"false\"}\n```r\n# first do the data table manipulation\nlabels_data <- penguins_fits |>\n  mutate(\n    body_mass_g = ___,\n    bill_length_mm = ___,\n    label = ___\n  )\nlabels_data\n\n# then plot\n```\n:::\n:::\n\n::: { .hint exercise=\"regression-plot-exercise\" }\n::: { .callout-tip title=\"Hint 2\" collapse=\"false\"}\n```r\n# first do the data table manipulation\nlabels_data <- penguins_fits |>\n  mutate(\n    body_mass_g = 5500,\n    bill_length_mm = 32,\n    label = glue(\"p = {signif(p.value, 3)}\")\n  ) |>\n  select(___)\nlabels_data\n\n# then plot\n```\n:::\n:::\n\n::: { .hint exercise=\"regression-plot-exercise\" }\n::: { .callout-tip title=\"Hint 3\" collapse=\"false\"}\n```r\n# first do the data table manipulation\nlabels_data <- penguins_fits |>\n  mutate(\n    body_mass_g = 5500,\n    bill_length_mm = 32,\n    label = glue(\"p = {signif(p.value, 3)}\")\n  ) |>\n  select(species, body_mass_g, bill_length_mm, label)\nlabels_data\n  \n# then plot\n```\n:::\n:::\n\n::: { .hint exercise=\"regression-plot-exercise\" }\n::: { .callout-tip title=\"Hint 4\" collapse=\"false\"}\n```r\n# first do the data table manipulation\nlabels_data <- penguins_fits |>\n  mutate(\n    body_mass_g = 5500,\n    bill_length_mm = 32,\n    label = glue(\"p = {signif(p.value, 3)}\")\n  ) |>\n  select(species, body_mass_g, bill_length_mm, label)\n  \n# then plot\nggplot(penguins, aes(body_mass_g, bill_length_mm)) +\n  geom_point(na.rm = TRUE) +\n  geom_smooth(method = \"lm\", formula = y ~ x, na.rm = TRUE) +\n  facet_wrap(vars(species)) +\n  geom_text(___)\n```\n:::\n:::\n\n::: { .hint exercise=\"regression-plot-exercise\" }\n::: { .callout-tip title=\"Hint 5\" collapse=\"false\"}\n```r\n# first do the data table manipulation\nlabels_data <- penguins_fits |>\n  mutate(\n    body_mass_g = 5500,\n    bill_length_mm = 32,\n    label = glue(\"p = {signif(p.value, 3)}\")\n  ) |>\n  select(species, body_mass_g, bill_length_mm, label)\n  \n# then plot\nggplot(penguins, aes(body_mass_g, bill_length_mm)) +\n  geom_point(na.rm = TRUE) +\n  geom_smooth(method = \"lm\", formula = y ~ x, na.rm = TRUE) +\n  facet_wrap(vars(species)) +\n  geom_text(\n    data = labels_data,\n    aes(___)\n  )\n```\n:::\n:::\n\n::: { .solution exercise=\"regression-plot-exercise\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\n# first do the data table manipulation\nlabels_data <- penguins_fits |>\n  mutate(\n    body_mass_g = 5500,\n    bill_length_mm = 32,\n    label = glue(\"p = {signif(p.value, 3)}\")\n  ) |>\n  select(species, body_mass_g, bill_length_mm, label)\n  \n# then plot\nggplot(penguins, aes(body_mass_g, bill_length_mm)) +\n  geom_point(na.rm = TRUE) +\n  geom_smooth(method = \"lm\", formula = y ~ x, na.rm = TRUE) +\n  facet_wrap(vars(species)) +\n  geom_text(\n    data = labels_data,\n    aes(label = label)\n  )\n```\n:::\n:::\n\nOnce you have successfully made the plot, you can try a few more things:\n\n- Place the labels for the different facets in different locations within each facet.\n- Use `hjust` and `vjust` in `geom_text()` to fine-tune where labels are placed.\n- Make labels that contain the *R*<sup>2</sup> value in addition to the *p* value.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}