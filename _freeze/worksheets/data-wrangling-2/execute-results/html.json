{
  "hash": "db47b072be7eba47e1aa5206965665df",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data wrangling 2\"\nauthor: \"Claus O. Wilke\"\nformat: live-html\nengine: knitr\nwebr:\n  render-df: gt-interactive\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## Introduction\n\nIn this worksheet, we will continue with basic data manipulations, now moving on to grouping and summarizing, making data tables wider or longer, and joining data tables.\n\nFirst we need to load the required R packages. Please wait a moment until the live R session is fully set up and all packages are loaded.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| warning: false\n#| edit: false\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n```\n:::\n\n\n\nNext we set up the data. We will be working with data on individual penguins in Antarctica.\n```r\npenguins\n```\n\n::: {.column-page}\n\n\n::: {.cell}\n```{webr}\n#| echo: false\npenguins\n```\n:::\n\n\n:::\n\n\n\n::: {.cell}\n```{webr}\n#| include: false\n# this chunk is hidden so students don't see the answer for\n# exercises further down\npenguins_long <- penguins |>\n  filter(!is.na(sex)) |>\n  group_by(species, sex) |>\n  summarize(mean_weight = mean(body_mass_g))\npenguins_wide <- penguins_long |>\n  pivot_wider(names_from = \"sex\", values_from = \"mean_weight\")\n```\n:::\n\n\n\nWe'll also be working with two datasets containing some information about Texas cities.\n\n\n\n::: {.cell}\n```{webr}\n#| include: false\nTX_population <- read_csv(file =\n\"city,year,population\nHouston,2014,2239558\nSan Antonio,2014,1436697\nAustin,2014,912791\nAustin,2010,790390\")\nTX_population\nTX_area <- read_csv(file =\n\"city,area\nHouston,607.5\nDallas,385.6\nAustin,307.2\")\nTX_area\n```\n:::\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nTX_population\nTX_area\n```\n:::\n\n\n\n## Analyzing subsets\n\nIn many data analysis settings, we want to break a dataset into subsets and then perform some summary calculation on each subset. The simplest example is counting, which we have done previously with the `count()` function.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins |>\n  count(species)\n```\n:::\n\n\n\nThis function subdivides the `penguins` dataset into subsets for each species and then calculates the number `n` for each subset, which is the number of observations in each subset.\n\nThe function `count()` here does all the work for us, but what if instead of counting we wanted to calculate the mean weight of the penguins for each species, or calculate the mean weight and count at the same time? We need a general framework that allows us to do these kinds of calculations with maximum flexibility.\n\nThe tidyverse approach is to first group a dataset with `group_by()` and then to calculate grouped summaries with `summarize()`.\n\n### Grouping\n\nLet's first consider just grouping. If we look at the raw R output of just the `penguins` table or the `penguins` table after running it through `group_by(species)`, we see that the table is the same, except in the second case there is a line `# Groups:   species [3]` which indicates that the table is grouped by species and there are three groups. (Here, we need to pipe the tables into the `print()` function to see the raw R output instead of a formatted table that would hide the grouping information.)\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins |>\n  print()\npenguins |>\n  group_by(species) |>\n  print()\n```\n:::\n\n\n\nWe can also group by multiple data columns at once, and we can undo any grouping with `ungroup()`.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins |>\n  group_by(species, island) |>\n  print()\npenguins |>\n  group_by(species) |>\n  ungroup() |>\n  print()\n```\n:::\n\n\n\nNow try this yourself. Group the penguins dataset by `sex` and `island`.\n\n\n\n::: {.cell exercise='group-basic'}\n```{webr}\n#| exercise: group-basic\npenguins |>\n  ___ |>\n  print()\n```\n:::\n\n\n\n::: { .hint exercise=\"group-basic\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(___) |>\n  print()\n```\n:::\n:::\n\n::: { .solution exercise=\"group-basic\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(sex, island) |>\n  print()\n```\n:::\n:::\n\nNow undo the previous grouping.\n\n\n\n::: {.cell exercise='ungroup'}\n```{webr}\n#| exercise: ungroup\n\n```\n:::\n\n\n\n::: { .hint exercise=\"ungroup\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(sex, island) |>\n  ___ |>\n  print()\n```\n:::\n:::\n\n::: { .solution exercise=\"ungroup\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(sex, island) |>\n  ungroup() |>\n  print()\n```\n:::\n:::\n\nAlso verify what the output looks like when you omit the `print()` function at the end.\n\n### Performing summaries\n\nOnce we have set up a grouping for a data table, we can then calculate summary data with the `summarize()` function. This function works similarly to `mutate()`, in that we provide it with statements of the form `<new column name> = <computation>`, where `<new column name>` stands for the name of the new column that is being created and `<computation>` stands for the computation that is used to generate the values in the new column. As an example, if we want to calculate the mean weight (body mass) of penguins, we could write `summarize(mean_weight = mean(body_mass_g))`, and this would create a new column called `mean_weight`.\n\nTry this out. First group by `sex` and then calculate the mean weight for each sex.\n\n\n\n::: {.cell exercise='summarize-simple'}\n```{webr}\n#| exercise: summarize-simple\npenguins |>\n  group_by(sex) |>\n  ___\n```\n:::\n\n\n\n::: { .hint exercise=\"summarize-simple\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(sex) |>\n  summarize(\n    ___ = ___\n  )\n```\n:::\n:::\n\n::: { .solution exercise=\"summarize-simple\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(sex) |>\n  summarize(\n    mean_weight = mean(body_mass_g)\n  )\n```\n:::\n:::\n\nWe see that male penguins on average are heavier than female penguins. We also see that there is a row containing `NA`s. This happens because there are a few entries in the dataset for which we know neither the penguins' sex nor their weight.\n\nNext, see if the pattern changes if we subdivide the dataset by species.\n\n\n\n::: {.cell exercise='summarize-simple2'}\n```{webr}\n#| exercise: summarize-simple2\npenguins |>\n  group_by(___) |>\n  ___\n```\n:::\n\n\n\n::: { .hint exercise=\"summarize-simple2\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(species, sex) |>\n  summarize(\n    ___ = ___\n  )\n```\n:::\n:::\n\n::: { .solution exercise=\"summarize-simple2\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(species, sex) |>\n  summarize(\n    mean_weight = mean(body_mass_g)\n  )\n```\n:::\n:::\n\nWhen running this code, you see a message that `summarise()` (the tidyverse uses British spelling internally) has grouped the output by `species`. This happens because if you group by multiple variables and then perform a summary it usually makes sense to keep all but the innermost groupings. Verify this is the case by piping the output from `summarize()` into `print()`.\n\nWe can perform multiple summaries at once by adding more statements inside the `summarize()` function. To try this out, calculate the mean bill length in addition to the mean weight.\n\n\n\n::: {.cell exercise='summarize-multiple'}\n```{webr}\n#| exercise: summarize-multiple\npenguins |>\n  group_by(species, sex) |>\n  summarize(\n    ___\n  )\n```\n:::\n\n\n\n::: { .hint exercise=\"summarize-multiple\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(species, sex) |>\n  summarize(\n    mean_weight = ___,\n    mean_bill_length = ___\n  )\n```\n:::\n:::\n\n::: { .solution exercise=\"summarize-multiple\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(species, sex) |>\n  summarize(\n    mean_weight = mean(body_mass_g),\n    mean_bill_length = mean(bill_length_mm)\n  )\n```\n:::\n:::\n\nWhen performing summaries, we often want to know how many observations there are in each group (i.e., we want to count). We can do this with the function `n()`, which inside `summarize()` gives us the group size. So, we can count by adding a statement such as `count = n()` inside `summarize()`. Try this out.\n\n\n\n::: {.cell exercise='summarize-multiple2'}\n```{webr}\n#| exercise: summarize-multiple2\npenguins |>\n  group_by(species, sex) |>\n  summarize(\n    ___\n  )\n```\n:::\n\n\n\n::: { .hint exercise=\"summarize-multiple2\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(species, sex) |>\n  summarize(\n    mean_weight = ___,\n    mean_bill_length = ___,\n    count = ___\n  )\n```\n:::\n:::\n\n::: { .solution exercise=\"summarize-multiple2\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(species, sex) |>\n  summarize(\n    mean_weight = mean(body_mass_g),\n    mean_bill_length = mean(bill_length_mm),\n    count = n()\n  )\n```\n:::\n:::\n\n\n### Removing missing values\n\nIf we try the previous calculation but grouping only by species and not by sex, we notice a problem: Most values have been replaced by `NA`.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins |>\n  group_by(species) |>\n  summarize(\n    mean_weight = mean(body_mass_g),\n    mean_bill_length = mean(bill_length_mm)\n  )\n```\n:::\n\n\n\nThis happens because R does not like to calculate the mean of a set of numbers where at least one is missing. Whenever there are missing values, we need to think carefully whether we can just ignore them or need to do something more sophisticated. In the penguins dataset there are only a handful of missing values, and therefore ignoring them is fine.\n\nWe can ignore missing values by setting `na.rm = TRUE` inside the `mean()` function. Try this out.\n\n\n\n::: {.cell exercise='summarize-na-rm'}\n```{webr}\n#| exercise: summarize-na-rm\npenguins |>\n  group_by(species) |>\n  summarize(\n    ___\n  )\n```\n:::\n\n\n\n::: { .hint exercise=\"summarize-na-rm\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(species) |>\n  summarize(\n    mean_weight = mean(body_mass_g, ___),\n    mean_bill_length = mean(bill_length_mm, ___)\n  )\n```\n:::\n:::\n\n::: { .solution exercise=\"summarize-na-rm\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  group_by(species) |>\n  summarize(\n    mean_weight = mean(body_mass_g, na.rm = TRUE),\n    mean_bill_length = mean(bill_length_mm, na.rm = TRUE)\n  )\n```\n:::\n:::\n\nAlternatively, we could filter out all rows that contain `NA`s in the columns of interest. We test whether a column contains `NA`s with `is.na(<column name>)`, and to keep rows without `NA`s we use `!is.na(<column name>)`. Try this out.\n\n\n\n::: {.cell exercise='summarize-na-rm-filter'}\n```{webr}\n#| exercise: summarize-na-rm-filter\npenguins |>\n  filter(___) |>\n  group_by(species) |>\n  summarize(\n    mean_weight = mean(body_mass_g),\n    mean_bill_length = mean(bill_length_mm)\n  )\n```\n:::\n\n\n\n::: { .hint exercise=\"summarize-na-rm-filter\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins |>\n  filter(!is.na(body_mass_g), ___) |>\n  group_by(species) |>\n  summarize(\n    mean_weight = mean(body_mass_g),\n    mean_bill_length = mean(bill_length_mm)\n  )\n```\n:::\n:::\n\n::: { .solution exercise=\"summarize-na-rm-filter\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  filter(!is.na(body_mass_g), !is.na(bill_length_mm)) |>\n  group_by(species) |>\n  summarize(\n    mean_weight = mean(body_mass_g),\n    mean_bill_length = mean(bill_length_mm)\n  )\n```\n:::\n:::\n\n## Making tables wider or longer\n\nFor efficient data processing, we usually want tables in long form, where each columns is one variable and each row is one observation. However, in some applications, for example when making a table easier to read for humans, a wide format can be preferred. In a wide format, some variables are displayed as column names, and other variables are distributed over multiple columns.\n\nConsider the following two versions of a summary table. The first is in long format, where sex is one column and the mean weight is another. \n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins_long\n```\n:::\n\n\n\nThe second is in wide format, where the values of the sex variable (female or male) are used as column headings, and the mean weight values are distributed over these two columns.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins_wide\n```\n:::\n\n\n\nYou can turn a long table into a wide table using the function `pivot_wider()`, which takes two arguments: `names_from` specifies the long column from which the new wide column names should be taken (here e.g., `\"sex\"`), and `values_from` specifies the long column from which the new wide values should be taken (here e.g., `\"mean_weight\"`). Try this out.\n\n\n\n::: {.cell exercise='pivot-wider'}\n```{webr}\n#| exercise: pivot-wider\npenguins_long |>\n  ___\n```\n:::\n\n\n\n::: { .hint exercise=\"pivot-wider\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins_long |>\n  pivot_wider(names_from = ___, values_from = ___)\n```\n:::\n:::\n\n::: { .solution exercise=\"pivot-wider\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins_long |>\n  pivot_wider(names_from = \"sex\", values_from = \"mean_weight\")\n```\n:::\n:::\n\nYou can similarly turn a wide table into a long one using the function `pivot_longer()`. It has arguments `cols`, `names_to`, and `values_to`. `cols` specifies the wide columns on which to operate, `names_to` specifies into which long columns the names of the wide columns should be written, and `values_to` specfies into which long columns the values of the wide columns should be written. Note that while `names_to` and `values_to` are specified as strings (that is, in quotes, such as `names_to = \"sex\"`), the `cols` argument does not use quotes (e.g., `cols = c(female, male)`).\n\nTry this out.\n\n\n\n::: {.cell exercise='pivot-longer'}\n```{webr}\n#| exercise: pivot-longer\npenguins_wide |>\n  ___\n```\n:::\n\n\n\n::: { .hint exercise=\"pivot-longer\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins_wide |>\n  pivot_longer(\n    cols = ___,\n    names_to = ___,\n    values_to = ___\n  )\n```\n:::\n:::\n\n::: { .solution exercise=\"pivot-longer\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins_wide |>\n  pivot_longer(\n    cols = c(female, male),\n    names_to = \"sex\",\n    values_to = \"mean_weight\"\n  )\n```\n:::\n:::\n\nNotice how the arguments `names_from` and `values_from` in `pivot_wider()` are exactly equivalent to `names_to` and `values_to` in `pivot_longer()`.\n\n\n## Combining datasets with joins\n\nFinally, we sometimes encounter the situation where we have two data sets that contain different pieces of information about the same subjects or objects, and we need to merge these tables for further analysis. In this situation, we need to perform a join, and there are multiple different types of joins available: `left_join()`, `right_join()`, `inner_join()`, `full_join()`. These joins all differ in how they handle cases where an observation is present in only one of the two tables but missing in the other.\n\nTwo explore joins, consider the following two datasets, which contain the population number of three Texas cities and the city areas, respectively. The cities in the two tables are not the same, on purpose.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nTX_population\nTX_area\n```\n:::\n\n\n\nTry to merge `TX_area` into `TX_population`, using `left_join()`.\n\n\n\n::: {.cell exercise='left-join'}\n```{webr}\n#| exercise: left-join\nleft_join(___)\n```\n:::\n\n\n\n::: { .hint exercise=\"left-join\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nleft_join(___, ___)\n```\n:::\n:::\n\n::: { .solution exercise=\"left-join\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nleft_join(TX_population, TX_area)\n```\n:::\n:::\n\nWhat happens if you reverse the two arguments?\n\nNow try the same with `full_join()`.\n\n\n\n::: {.cell exercise='full-join'}\n```{webr}\n#| exercise: full-join\n```\n:::\n\n\n\n::: { .hint exercise=\"full-join\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nfull_join(___, ___)\n```\n:::\n:::\n\n::: { .solution exercise=\"full-join\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nfull_join(TX_population, TX_area)\n```\n:::\n:::\n\nTry also `right_join()` and `inner_join()`. See if you can describe what each join function does and how they differ from one another.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}