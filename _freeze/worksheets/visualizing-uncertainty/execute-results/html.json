{
  "hash": "6d0769c7e5ea675a6913e217e4a0470b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Visualizing uncertainty\"\nauthor: \"Claus O. Wilke\"\nformat: live-html\nengine: knitr\nwebr:\n  render-df: gt-interactive\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n## Introduction\n\nIn this worksheet, we will discuss how to visualize uncertainty estimates obtained from a model fit.\n\nFirst we need to load the required R packages. Please wait a moment until the live R session is fully set up and all packages are loaded.\n\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| warning: false\n#| edit: false\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(ggdist)\nlibrary(distributional)\nlibrary(gapminder)\n```\n:::\n\n\n\n\n\nWe will be working with the dataset `gapminder` containing data on  data on life expectancy, GDP per capita, and population by country and year.\n\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\ngapminder\n```\n:::\n\n\n\n\n\n## Plotting model estimates as error bars\n\nWhenever we are working with linear models applied to a complex dataset, we typically end up with a summary table that holds various parameter estimates with associated standard errors. For example, for the `gapminder` dataset, we can fit life expectancy against log-transformed GDP per capita separately for each continent and year. We end up with a set of estimates of the slope of the regression line for each subset of data.\n\nThe pipeline to perform these model fits and extract the estimates and standard errors has been discussed in the preceding worksheet, and we take it as a given here.\n\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nlm_data <- gapminder |>\n  nest(data = -c(continent, year)) |>\n  mutate(\n    fit = map(data, ~lm(lifeExp ~ log(gdpPercap), data = .x)),\n    tidy_out = map(fit, tidy)\n  ) |>\n  unnest(cols = tidy_out) |>\n  select(-fit, -data) |>\n  # leave out the intercept term and the continent Oceania for simplicity\n  filter(term != \"(Intercept)\", continent != \"Oceania\")\n\nlm_data\n```\n:::\n\n\n\n\n\nNext, we can visualize these estimates. Let's focus just on the Americas. We could make a scatter plot of the estimate (which is the slope of the regression line) against year.\n\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nlm_data |>\n  filter(continent == \"Americas\") |>\n  ggplot(aes(year, estimate)) +\n  geom_point()\n```\n:::\n\n\n\n\n\nHowever, this does not show the uncertainty of each estimate. The simplest way to show uncertainty is via error bars, which we can plot in ggplot with `geom_pointrange()`. This geom takes in addition to the `x` and `y` aesthetics an additional set of aesthetics `ymin` and `ymax` (or alternatively `xmin` and `xmax`, depending on whether error bars should be shown vertically or horizontally), which represent the end points of the error bars. Importantly, you need to calculate these endpoints yourself, the geom cannot calculate them from the estimate and standard error.\n\nFor sufficiently large data sets, we can make a normal approximation and assume that the 95% confidence interval corresponds to the mean +/- 1.96 times the error. Thus, we calculate lower and upper bounds in this way and then plot.\n\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nlm_data |>\n  filter(continent == \"Americas\") |>\n  mutate(\n    lower = estimate - 1.96*std.error,\n    upper = estimate + 1.96*std.error\n  ) |>\n  ggplot(aes(year, estimate)) +\n  geom_pointrange(aes(ymin = lower, ymax = upper))\n```\n:::\n\n\n\n\n\nTo see if you understand these concepts, repeat this plot but with two modifications:\n\n- Calculate a 99% confidence interval instead of a 95% confidence interval. The multiplier for a 99% confidence interval is 2.58.\n- Plot year along the y axis and the estimate along the x axis. This requires the error bars to be laid out horizontally.\n\n\n\n\n\n::: {.cell exercise='error-bars-horizontal'}\n```{webr}\n#| exercise: error-bars-horizontal\n\n```\n:::\n\n\n\n\n\n::: { .hint exercise=\"error-bars-horizontal\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nlm_data |>\n  filter(continent == \"Americas\") |>\n  mutate(\n    lower = estimate - 2.58*std.error,\n    upper = estimate + 2.58*std.error\n  ) |>\n  ggplot(___) +\n  ___\n```\n:::\n:::\n\n::: { .solution exercise=\"error-bars-horizontal\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nlm_data |>\n  filter(continent == \"Americas\") |>\n  mutate(\n    lower = estimate - 2.58*std.error,\n    upper = estimate + 2.58*std.error\n  ) |>\n  ggplot(aes(estimate, year)) +\n  geom_pointrange(aes(xmin = lower, xmax = upper))\n```\n:::\n:::\n\nThere are two related geoms, `geom_linerange()` and `geom_errorbar()`, that differ in minor ways from `geom_pointrange()`. First, both omit the point in the middle, so you have to plot it manually. Second, `geom_errorbar()` shows error bars with a little cap at the end. Repeat the previous plot using both of these geoms.\n\n\n\n\n\n::: {.cell exercise='error-bars-horizontal2'}\n```{webr}\n#| exercise: error-bars-horizontal2\n\n```\n:::\n\n\n\n\n\n::: { .hint exercise=\"error-bars-horizontal2\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nlm_data |>\n  filter(continent == \"Americas\") |>\n  mutate(\n    lower = estimate - 2.58*std.error,\n    upper = estimate + 2.58*std.error\n  ) |>\n  ggplot(___) +\n  ___\n```\n:::\n:::\n\n::: { .solution exercise=\"error-bars-horizontal2\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nlm_data |>\n  filter(continent == \"Americas\") |>\n  mutate(\n    lower = estimate - 2.58*std.error,\n    upper = estimate + 2.58*std.error\n  ) |>\n  ggplot(aes(estimate, year)) +\n  geom_linerange(aes(xmin = lower, xmax = upper)) +\n  geom_point(color = \"navyblue\")\n\nlm_data |>\n  filter(continent == \"Americas\") |>\n  mutate(\n    lower = estimate - 2.58*std.error,\n    upper = estimate + 2.58*std.error\n  ) |>\n  ggplot(aes(estimate, year)) +\n  geom_errorbar(aes(xmin = lower, xmax = upper)) +\n  geom_point(color = \"navyblue\")\n```\n:::\n:::\n\n## Half-eyes, gradient intervals, etc.\n\nIf we want to go beyond simple error bars, the **ggdist** package provides many more sophisticated approaches to visualizing uncertainty distributions. These include `stat_dist_halfeye()`, `stat_dist_gradientinterval()`, and `stat_dist_dotsinterval()` to draw half-eyes, gradient intervals, and quantile dotplots, respectively. All these functions take an unusual `aes()` argument of the form `aes(dist = <distribution function>)`. Here, `<distribution function>` is a distribution function from the **distributional** package converting the parameter estimate and standard error (and possibly other values, such as the residual degrees of freedom) into an error distribution. For example, the following mapping would use the `estimate` and `std.error` columns in the data to create a normal error distribution.\n\n```r\naes(dist = dist_normal(mu = estimate, sigma = std.error))\n```\n\nTo demonstrate how this works, we'll make a half-eye plot for the gapminder regression models, focusing on the year 1952 but keeping all continents.\n\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nlm_data |>\n  filter(year == 1952) |>\n  mutate(continent = fct_reorder(continent, estimate)) |>\n  ggplot(aes(x = estimate, y = continent)) +\n  stat_dist_halfeye(\n    aes(dist = dist_normal(mu = estimate, sigma = std.error)),\n    fill = \"skyblue\"\n  )\n```\n:::\n\n\n\n\n\nTry this for yourself. To change things up, pick a different year, e.g. 2002, and a different fill color.\n\n\n\n\n\n::: {.cell exercise='halfeye-exercise'}\n```{webr}\n#| exercise: halfeye-exercise\n\n```\n:::\n\n\n\n\n\n::: { .solution exercise=\"halfeye-exercise\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nlm_data |>\n  filter(year == 2002) |>\n  mutate(continent = fct_reorder(continent, estimate)) |>\n  ggplot(aes(x = estimate, y = continent)) +\n  stat_dist_halfeye(\n    aes(dist = dist_normal(mu = estimate, sigma = std.error)),\n    fill = \"olivedrab\"\n  )\n```\n:::\n:::\n\nNow use `stat_dist_gradientinterval()` instead of `stat_dist_halfeye()`.\n\n\n\n\n\n::: {.cell exercise='gradientinterval-exercise'}\n```{webr}\n#| exercise: gradientinterval-exercise\n\n```\n:::\n\n\n\n\n\n::: { .solution exercise=\"gradientinterval-exercise\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nlm_data |>\n  filter(year == 2002) |>\n  mutate(continent = fct_reorder(continent, estimate)) |>\n  ggplot(aes(x = estimate, y = continent)) +\n  stat_dist_gradientinterval(\n    aes(dist = dist_normal(mu = estimate, sigma = std.error))\n  )\n```\n:::\n:::\n\nAnd finally use `stat_dist_dotsinterval()`. This stat takes an additional parameter `quantiles` that determines the number of quantile dots to draw. Try `quantiles = 20`.\n\n\n\n\n\n::: {.cell exercise='dotsinterval-exercise'}\n```{webr}\n#| exercise: dotsinterval-exercise\n\n```\n:::\n\n\n\n\n\n::: { .hint exercise=\"dotsinterval-exercise\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nlm_data |>\n  filter(year == 2002) |>\n  mutate(continent = fct_reorder(continent, estimate)) |>\n  ggplot(aes(x = estimate, y = continent)) +\n  stat_dist_dotsinterval(\n    aes(dist = dist_normal(mu = estimate, sigma = std.error)),\n    fill = \"olivedrab\",\n    quantiles = ___\n  )\n```\n:::\n:::\n\n::: { .solution exercise=\"dotsinterval-exercise\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nlm_data |>\n  filter(year == 2002) |>\n  mutate(continent = fct_reorder(continent, estimate)) |>\n  ggplot(aes(x = estimate, y = continent)) +\n  stat_dist_dotsinterval(\n    aes(dist = dist_normal(mu = estimate, sigma = std.error)),\n    fill = \"olivedrab\",\n    quantiles = 20\n  )\n```\n:::\n:::\n\nChange both the year and the number of quantiles to see how quantile dotplots look in a variety of different scenarios. The possible year values range from 1952 to 2007 in five-year increments.\n\n",
    "supporting": [
      "visualizing-uncertainty_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}