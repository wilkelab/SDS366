{
  "hash": "c48f582b61edfb988f651fddbab6a022",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functional programming\"\nauthor: \"Claus O. Wilke\"\nformat: live-html\nengine: knitr\nwebr:\n  render-df: paged-table\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## Introduction\n\nIn this worksheet, we will discuss elements of functional programming in R.\n\nFirst we need to load the required R packages. Please wait a moment until the live R session is fully set up and all packages are loaded.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| warning: false\n#| edit: false\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n```\n:::\n\n\n\nNext we set up the data. We will be working with data on individual penguins in Antarctica.\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins\n```\n:::\n\n\n\n## Calling functions repeatedly\n\nThe core concept in functional programming is a function, which is a way of running the same code multiple times on different input data. In R, functions are defined with the `function` keyword, followed by a list of arguments in parentheses and the body of the function in curly braces. For example, the following code defines a function that squares a numeric value.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nsquare <- function(x) {\n  x^2\n}\n```\n:::\n\n\nThe variable `x` is the argument of the function, and it can then be used in the body of the function for computations. The result of the last expression in the function body is used as the return value of the function, so this simple function returns the square of its argument. Note that functions are first-class objects in R, and we can assign a function to a variable using `<-`, just like any other assignment in R.\n\nTo call a function, we write the name of the function followed by parentheses enclosing the argument(s). For example, the following code calculates the squares of 3, 4, and 5:\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nsquare(3)\nsquare(4)\nsquare(5)\n```\n:::\n\n\n\nWe often want to run a function on a set of given input values. In procedural programming, we would typically do this with a `for` loop. The equivalent concept in functional programming is the map. Specifically, the `map()` function takes as input a vector of values (e.g., the numbers from 3 to 5, `3:5`) and a function name (e.g. `square`, note no parentheses) and applies the function to each value in the input vector.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nmap(3:5, square)\n```\n:::\n\n\n\nThe return result is a list, hence the weird double brackets (`[[1]]`, `[[2]]`, etc.). If instead we want a regular vector of numbers, we can use `map_dbl()`. Here, \"dbl\" stands for \"double\", which is shorthand for \"double precision floating point numbers\", the default numeric datatype of R.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nmap_dbl(3:5, square)\n```\n:::\n\n\n\nWhen using any of the map functions, instead of providing a function by name, we can also define a function in place, as a formula. We do so by writing an R expression with a tilde (`~`) in front. The parameter supplied by the map function is always called `.x`. So `~.x^2` is equivalent to `function(.x) { .x^2 }`.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nmap_dbl(1:3, ~.x^2)\n```\n:::\n\n\n\nNow try these concepts yourself. First write a function that calculates the cube of its argument.\n\n\n\n::: {.cell exercise='cube'}\n```{webr}\n#| exercise: cube\n\n```\n:::\n\n\n\n::: { .hint exercise=\"cube\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\ncube <- function(___) {\n  ___\n}\n\ncube(2)\ncube(3)\ncube(4)\n```\n:::\n:::\n\n::: { .solution exercise=\"cube\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\ncube <- function(x) {\n  x^3\n}\n\ncube(2)\ncube(3)\ncube(4)\n```\n:::\n:::\n\n\nNow use this function in conjunction with either `map()` or `map_dbl()` to calculate the first 5 cubes.\n\n\n\n::: {.cell exercise='cube-map'}\n```{webr}\n#| exercise: cube-map\n\n```\n:::\n\n\n\n::: { .hint exercise=\"cube-map\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\ncube <- function(x) {\n  x^3\n}\n\nmap(1:5, ___)\n```\n:::\n:::\n\n::: { .solution exercise=\"cube-map\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\ncube <- function(x) {\n  x^3\n}\n\nmap(1:5, cube)\nmap_dbl(1:5, cube)\n```\n:::\n:::\n\nNow calculate the first 5 cubes using the in-place function definition via a formula.\n\n\n\n::: {.cell exercise='cube-formula'}\n```{webr}\n#| exercise: cube-formula\n\n```\n:::\n\n\n\n::: { .hint exercise=\"cube-formula\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nmap(1:5, ~___)\n```\n:::\n:::\n\n::: { .solution exercise=\"cube-formula\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nmap(1:5, ~.x^3)\nmap_dbl(1:5, ~.x^3)\n```\n:::\n:::\n\nThe `map()` function applies a function taking a single argument to a single vector of values. But what if we have a function with two arguments, say, a function that takes values `x` and `y` and returns their product? In this case, we can use `map2()`, which requires two input vectors and a function of two arguments.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nmap2(1:3, 2:4, function(x, y) x*y)\n```\n:::\n\n\n\nTo try this out, use a single `map2()` expression to calculate the square of 3, the cube of 4, and the fourth power of 5.\n\n\n\n::: {.cell exercise='map2-exercise'}\n```{webr}\n#| exercise: map2-exercise\n\n```\n:::\n\n\n\n::: { .hint exercise=\"map2-exercise\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nmap2(3:5, 2:4, ___)\n```\n:::\n:::\n\n::: { .solution exercise=\"map2-exercise\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nmap2(3:5, 2:4, function(x, y) x^y)\n```\n:::\n:::\n\nFinally, sometimes we want to call a function repeatedly but not to collect the return values but rather for side effects, such as printing output. In this case, we use `walk()` instead of `map()`.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nwalk(1:3, print)\n```\n:::\n\n\n\nTry this out by calling the following function `print_value()` on the input values 1, 2, and 3.\n\n\n\n::: {.cell exercise='walk-exercise'}\n```{webr}\n#| exercise: walk-exercise\nprint_value <- function(x) {\n  cat(\"The value is\", x, \".\\n\")\n}\n```\n:::\n\n\n\n::: { .hint exercise=\"walk-exercise\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nprint_value <- function(x) {\n  cat(\"The value is\", x, \"\\n\")\n}\n\nwalk(1:3, ___)\n```\n:::\n:::\n\n::: { .solution exercise=\"walk-exercise\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nprint_value <- function(x) {\n  cat(\"The value is\", x, \"\\n\")\n}\n\nwalk(1:3, print_value)\n```\n:::\n:::\n\n## Nesting and unnesting\n\nFunctional programming becomes a very powerful concept in data analysis when combined with nested data frames, so we will be discussing nesting and unnesting next.\n\nWe use the function `nest()` to take rectangular regions in a data table and compress them into a single cell in a higher-level table. This process is useful when we want to store all the information for one category of data in a single cell.\n\nFor example, we can store all the penguin data in a nested table with three rows and two columns, where one column contains the penguins species and the other column contains all the data for that species. We generate such a table as follows.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins |>\n  nest(data = -species)\n```\n:::\n\n\n\nThe specification `data = -species` means \"create a new column called `data` and move everything into this column except the contents of the `species` column\". The `nest()` function will automatically generate exactly one row for each unique combination of data values that are not being nested. Therefore, we end up with three rows, one for each species.\n\nThe `data` column is a list column, and we can access individual values in it via list indexing, i.e., double square brackets. So, `data[[1]]` is the first nested table, `data[[2]]` is the second nested table, and so on. For example, the following code extracts all the data for Gentoo penguins.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins_nested <- penguins |>\n  nest(data = -species)\n\npenguins_nested$data[[2]] # data table for Gentoo penguins\n```\n:::\n\n\n\nNow try this out. First, make a nested table but nest by `island`.\n\n\n\n::: {.cell exercise='island-nested'}\n```{webr}\n#| exercise: island-nested\npenguins |>\n  nest(___)\n```\n:::\n\n\n\n::: { .hint exercise=\"island-nested\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins |>\n  nest(data = ___)\n```\n:::\n:::\n\n::: { .solution exercise=\"island-nested\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  nest(data = -island)\n```\n:::\n:::\n\nNow extract the data table for the third island.\n\n\n\n::: {.cell exercise='island-nested-extract'}\n```{webr}\n#| exercise: island-nested-extract\npenguins_nested <- penguins |>\n  ___\n\npenguins_nested$___\n```\n:::\n\n\n\n::: { .hint exercise=\"island-nested-extract\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins_nested <- penguins |>\n  nest(data = -island)\n\npenguins_nested$data[[___]]\n```\n:::\n:::\n\n::: { .solution exercise=\"island-nested-extract\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins_nested <- penguins |>\n  nest(data = -island)\n\npenguins_nested$data[[3]]\n```\n:::\n:::\n\nNow nest by `species` and `island` at the same time. You can nest by multiple columns by excluding both from the newly created data column, via `data = -c(species, island)`.\n\n\n\n::: {.cell exercise='species-island-nested'}\n```{webr}\n#| exercise: species-island-nested\npenguins |>\n  nest(___)\n```\n:::\n\n\n\n::: { .hint exercise=\"species-island-nested\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins |>\n  nest(data = ___)\n```\n:::\n:::\n\n::: { .solution exercise=\"species-island-nested\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  nest(data = -c(species, island))\n```\n:::\n:::\n\nTo unnest, we use the function `unnest()`. Its argument `cols` takes the name of the column to be unnested. For example, if we nest into the `data` column, as we have done in all examples so far, then `cols = data` unnests this column.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins_nested <- penguins |>\n  nest(data = -species)\n\npenguins_nested |>\n  unnest(cols = data)\n```\n:::\n\n\n\nTry this for yourself in the following example. Note that the data column has a different name here.\n\n\n\n::: {.cell exercise='unnest'}\n```{webr}\n#| exercise: unnest\npenguins_nested <- penguins |>\n  nest(species_data = -species)\n\npenguins_nested |>\n  ___\n```\n:::\n\n\n\n::: { .hint exercise=\"unnest\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\npenguins_nested <- penguins |>\n  nest(species_data = -species)\n\npenguins_nested |>\n  unnest(cols = ___)\n```\n:::\n:::\n\n::: { .solution exercise=\"unnest\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins_nested <- penguins |>\n  nest(species_data = -species)\n\npenguins_nested |>\n  unnest(cols = species_data)\n```\n:::\n:::\n\n## Plotting subsets of data\n\nNow we will use the concepts of mapping and nesting to automatically create plots of subsets of data. Specifically, we will make pie charts of the species composition of penguin species on the different islands. The pie charts will be generated by the following function, which takes as arguments the data for the island and the name of the island.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nmake_pie <- function(data, island) {\n  data |>\n    ggplot(aes(y = \"\", fill = species)) +\n    geom_bar(position = \"fill\") +\n    scale_y_discrete(name = NULL, breaks = NULL) +\n    scale_x_continuous(labels = scales::percent) +\n    ggtitle(island) +\n    coord_polar()\n}\n```\n:::\n\n\n\nWe can use this function for a single island like so.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\npenguins |>\n  filter(island == \"Dream\") |>\n  make_pie(\"Dream\")\n```\n:::\n\n\n\nHowever, here we want to automate the process of calling this function for all islands separately. See if you can make this happen, using the functions `nest()`, `mutate()`, `map2()`, `pull()`, and `walk()`. Note: The individual stages of the calculation are provided as hints, so you can click through them one-by-one if you get stuck or something is not clear.\n\n\n\n::: {.cell exercise='island-pies'}\n```{webr}\n#| exercise: island-pies\n\n```\n:::\n\n\n\n::: { .hint exercise=\"island-pies\" }\n::: { .callout-tip title=\"Hint 1\" collapse=\"false\"}\nFirst create a nested table so it has three rows, one for each island. The table should have a column `data` whose entries contain all the data for each island.\n```\npenguins |>\n  nest(___)\n```\n:::\n:::\n\n::: { .hint exercise=\"island-pies\" }\n::: { .callout-tip title=\"Hint 2\" collapse=\"false\"}\nNext use `mutate()` and `map2()` to run the `make_pie()` function on each subset of data and store the resulting plots.\n```r\npenguins |>\n  # move all data for each island into a single\n  # entry in a column called `data`\n  nest(data = -island) |>\n  ___ # continue here with mutate\n```\n:::\n:::\n\n::: { .hint exercise=\"island-pies\" }\n::: { .callout-tip title=\"Hint 3\" collapse=\"false\"}\nNext extract the `plots` column.\n```r\npenguins |>\n  # move all data for each island into a single\n  # entry in a column called `data`\n  nest(data = -island) |>\n  # run the `make_pie()` function on each dataset separately,\n  # store result in a column `plots`\n  mutate(\n    plots = map2(data, island, make_pie)\n  ) |>\n  ___ # extract the plots column\n```\n:::\n:::\n\n::: { .hint exercise=\"island-pies\" }\n::: { .callout-tip title=\"Hint 4\" collapse=\"false\"}\nNext use `walk()` to print all the plots.\n```r\npenguins |>\n  # move all data for each island into a single\n  # entry in a column called `data`\n  nest(data = -island) |>\n  # run the `make_pie()` function on each dataset separately,\n  # store result in a column `plots`\n  mutate(\n    plots = map2(data, island, make_pie)\n  ) |>\n  pull(plots) |>  # extract the column holding the plots\n  ___ # use `walk()` to print all the plots\n```\n:::\n:::\n\n::: { .solution exercise=\"island-pies\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\npenguins |>\n  # move all data for each island into a single\n  # entry in a column called `data`\n  nest(data = -island) |>\n  # run the `make_pie()` function on each dataset separately,\n  # store result in a column `plots`\n  mutate(\n    plots = map2(data, island, make_pie)\n  ) |>\n  pull(plots) |> # extract the column holding the plots\n  walk(print)    # print all plots one by one\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}