{
  "hash": "198fab84be32c57bc682c5a1f0c8d0c5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Getting to know your data 1\"\nauthor: \"Claus O. Wilke\"\nformat: live-html\nengine: knitr\nwebr:\n  render-df: gt-interactive\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n## Introduction\n\nIn this worksheet, we will discuss how to perform basic inspection of a dataset and simple data-cleaning tasks.\n\nFirst we need to load the required R packages. Please wait a moment until the live R session is fully set up and all packages are loaded.\n\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| warning: false\n#| edit: false\nlibrary(tidyverse)\nlibrary(naniar)\n```\n:::\n\n\n\n\n\nNext we set up the data.\n\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| warning: false\nNCbirths <- read_csv(\n  \"https://wilkelab.org/SDS366/datasets/NCbirths.csv\",\n  na = c(\"\", \"NA\", \"#N/A\")\n) |>\n  # missing weeks values are encoded as -999 in the data file\n  naniar::replace_with_na_at(\"Weeks\", ~.x < 0)\n```\n:::\n\n\n\n\n\nWe will be working with the dataset `NCbirths`, which contains data about 1450 births in the state of North Carolina in 2001.\n```r\nNCbirths\n```\n\n::: {.column-page}\n\n\n\n\n::: {.cell}\n```{webr}\n#| echo: false\nNCbirths\n```\n:::\n\n\n\n\n:::\n\n\n## Basic inspection of the data\n\nWhen first working with a new dataset, you should always start by just looking at the data. The simplest way to do this is to just enter the name of the dataset in the R command line and run, which causes the data to be printed. You can also use `head(...)` to only see the first six rows or `glimpse(...)` to get a list of all columns with their type and first few values.\n\nTry this yourself. Write code that displays the entire `NCbirths` dataset, the first six rows, or a list of all columns.\n\n\n\n\n\n::: {.cell exercise='glimpse'}\n```{webr}\n#| exercise: glimpse\n\n```\n:::\n\n\n\n\n\n::: { .hint exercise=\"glimpse\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nNCbirths\n```\n:::\n:::\n\n::: { .solution exercise=\"glimpse\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nhead(NCbirths)\nglimpse(NCbirths)\nNCbirths\n```\n:::\n:::\n\nIt is often useful to get a list of all names of the columns in a data frame. You can obtain this with `names(...)`. Try this yourself.\n\n\n\n\n\n::: {.cell exercise='names'}\n```{webr}\n#| exercise: names\n\n```\n:::\n\n\n\n\n\n::: { .solution exercise=\"names\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nnames(NCbirths)\n```\n:::\n:::\n\nTo inspect individual columns, you can extract them either with `pull()` like so: `data |> pull(column)` or with the `$` operator like so: `data$column`. The second option is shorter but the first option integrates better into longer analysis pipelines. Try both options on the `NCbirths` dataset, for example for the `Smoke` column.\n\n\n\n\n\n::: {.cell exercise='pull'}\n```{webr}\n#| exercise: pull\n\n```\n:::\n\n\n\n\n\n::: { .solution exercise=\"pull\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\n# option using pull()\nNCbirths |>\n  pull(Smoke)\n\n# option using $ operator\nNCbirths$Smoke\n```\n:::\n:::\n\nFinally, to see all distinct values in a column, you can apply the function `unique()` to it. Try this with the `Smoke` column.\n\n\n\n\n\n::: {.cell exercise='unique'}\n```{webr}\n#| exercise: unique\n\n```\n:::\n\n\n\n\n\n::: { .hint exercise=\"unique\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nNCbirths |>\n  pull(Smoke) |>\n  ___\n```\n:::\n:::\n\n::: { .solution exercise=\"unique\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nNCbirths |>\n  pull(Smoke) |>\n  unique()\n```\n:::\n:::\n\n\n## Recoding of data values\n\nWe frequently want to recode data values such that they are more humanly readable. For example, we might want to write smoker/non-smoker instead of 1/0. We can do this with `if_else()`, which takes three arguments: a logical condition, the data value if the logical condition is true, and the data value if the logical condition is false. Try this out on the `Smoke` column, creating a new column `Smoke_recoded` that is human-readable.\n\n\n\n\n\n::: {.cell exercise='ifelse'}\n```{webr}\n#| exercise: ifelse\nNCbirths |>\n  mutate(\n    Smoke_recoded = ___ # recode the `Smoke` variable here\n  ) |>\n  select(Smoke, Smoke_recoded) |>\n  unique()\n```\n:::\n\n\n\n\n\n::: { .hint exercise=\"ifelse\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nNCbirths |>\n  mutate(\n    Smoke_recoded = if_else(___, ___, ___)\n  ) |>\n  select(Smoke, Smoke_recoded) |>\n  unique()\n```\n:::\n:::\n\n::: { .solution exercise=\"ifelse\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nNCbirths |>\n  mutate(\n    Smoke_recoded = if_else(Smoke == 0, \"non-smoker\", \"smoker\")\n  ) |>\n  select(Smoke, Smoke_recoded) |>\n  unique()\n```\n:::\n:::\n\nWhen you want to recode a variable with more than two categories, you could nest `if_else()` commands, but usually it is simpler to use `case_when()`. With `case_when()`, you provide a list of conditions and corresponding data values as formulas of the form `condition ~ data value`. For example, the recoding exercise for the `Smoke` column could be written with `case_when()` as follows:\n\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nNCbirths |>\n  mutate(\n    Smoke_recoded = case_when(\n      Smoke == 0 ~ \"non-smoker\",\n      Smoke == 1 ~ \"smoker\",\n      TRUE ~ NA # fallback if no other condition matches\n    ) \n  ) |>\n  select(Smoke, Smoke_recoded) |>\n  unique()\n```\n:::\n\n\n\n\n\nWhen using `case_when()`, it is usually a good idea to provide an explicit fallback that is used when none of the earlier conditions match. The logical conditions are evaluated in order, so you want to list the most specific conditions first and the least specific conditions last. The fallback condition is simply `TRUE`. It applies always if no previous condition applied.\n\nNow use `case_when()` to recode the `Plural` column into singlet/twins/triplets.\n\n\n\n\n\n::: {.cell exercise='case_when'}\n```{webr}\n#| exercise: case_when\nNCbirths |>\n  mutate(\n    Plural_recoded = ___\n  ) |>\n  select(Plural, Plural_recoded) |>\n  unique()\n```\n:::\n\n\n\n\n\n::: { .hint exercise=\"case_when\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nNCbirths |>\n  mutate(\n    Plural_recoded = case_when(\n      Plural == 1 ~ \"singlet\",\n      ___,\n      ___,\n      ___\n    )\n  ) |>\n  select(Plural, Plural_recoded) |>\n  unique()\n```\n:::\n:::\n\n::: { .solution exercise=\"case_when\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nNCbirths |>\n  mutate(\n    Plural_recoded = case_when(\n      Plural == 1 ~ \"singlet\",\n      Plural == 2 ~ \"twins\",\n      Plural == 3 ~ \"triplets\",\n      TRUE ~ NA\n    )\n  ) |>\n  select(Plural, Plural_recoded) |>\n  unique()\n```\n:::\n:::\n\n\n## Summaries of data columns\n\nWhen exploring a new dataset, it is usually a good idea to look at summaries of the data values in each column, to get a quick sense of the range of data values, to see whether there are any unexpected outliers, etc. There are two useful functions for this purpose, `summary()` for numerical data and `table()` for categorical data.\n\nFirst try this for numerical data. Perform summaries for the data columns `MomAge`, `Weeks`, and `BirthWeightGm`.\n\n\n\n\n\n::: {.cell exercise='summary'}\n```{webr}\n#| exercise: summary\n\n```\n:::\n\n\n\n\n\n::: { .hint exercise=\"summary\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nsummary(NCbirths$MomAge)\n___\n___\n```\n:::\n:::\n\n::: { .solution exercise=\"summary\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nsummary(NCbirths$MomAge)\nsummary(NCbirths$Weeks)\nsummary(NCbirths$BirthWeightGm)\n```\n:::\n:::\n\nNow try this for categorical data. Perform summaries for the data columns `Plural`, `Smoke`, and `RaceMom`.\n\n\n\n\n\n::: {.cell exercise='table'}\n```{webr}\n#| exercise: table\n\n```\n:::\n\n\n\n\n\n::: { .hint exercise=\"table\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\ntable(NCbirths$Plural)\n___\n___\n```\n:::\n:::\n\n::: { .solution exercise=\"table\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\ntable(NCbirths$Plural)\ntable(NCbirths$Smoke)\ntable(NCbirths$RaceMom)\n```\n:::\n:::\n\nDo you understand what the output means? If not, look it up in the R documentation for the `table()` function.\n\nOne quirk of the `table()` function is that by default it omits any `NA` values. However, it is important to know whether there are any `NA` values in a data column or not. We can get `table()` to tabulate `NA`s as well by providing it with the argument `useNA = \"ifany\"`. Repeat the previous exercise with this modification and see which of the three columns `Plural`, `Smoke`, or `RaceMom` contain any `NA`s.\n\n\n\n\n\n::: {.cell exercise='table_NA'}\n```{webr}\n#| exercise: table_NA\n\n```\n:::\n\n\n\n\n\n::: { .hint exercise=\"table_NA\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\ntable(NCbirths$Plural, useNA = \"ifany\")\n___\n___\n```\n:::\n:::\n\n::: { .solution exercise=\"table_NA\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\ntable(NCbirths$Plural, useNA = \"ifany\")\ntable(NCbirths$Smoke, useNA = \"ifany\")\ntable(NCbirths$RaceMom, useNA = \"ifany\")\n```\n:::\n:::\n\n",
    "supporting": [
      "know-your-data-1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}