{
  "hash": "f2f53ccd8e2c53753680a65e7a4019b9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introduction to R\"\nauthor: \"Claus O. Wilke\"\nformat: live-html\nengine: knitr\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell edit='false'}\n```{webr}\n#| warning: false\n#| edit: false\n#| echo: false\nlibrary(tidyverse) # load tidyverse so all the webR packages get loaded\ndetach(\"package:tidyverse\") # detach so we can later see the loading message\ndetach(\"package:tidyr\")\ndetach(\"package:ggplot2\")\ndetach(\"package:purrr\")\ndetach(\"package:forcats\")\ndetach(\"package:readr\")\ndetach(\"package:stringr\")\ndetach(\"package:lubridate\")\n```\n:::\n\n\n\n\n## Introduction\n\nIn this worksheet, we will cover some of the basic concepts of the R programming language. The worksheet is not an exhaustive introduction to the language, but it will cover the most important concepts and in particular the concepts where R differs from other languages you may be familiar with. If you have prior R experience you can skip this worksheet.\n\nR is a language designed for interactive data analysis, and some of its features may seem strange when approached from the perspective of a general purpose programming language. Keep in mind that language features that simplify interactive work may get in the way of writing complex programs and vice versa.\n\nPlease wait a moment until the live R session is fully set up and all packages are loaded.\n\n## Basic data types\n\nR implements all the standard mathematical operations you would expect, such as addition, subtraction, etc., as well as special functions. This will generally work just like you would expect from other languages.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n5 + 2\n7 * (3 - 2.9)\nexp(0.5)\ncos(2*pi)\n5^2\n```\n:::\n\n\n\n\nTry this out. Can you calculate 2 to the power of 5? Or the sin of pi/4? Or the square-root of 2?\n\n\n\n\n::: {.cell exercise='basic-math'}\n```{webr}\n#| exercise: basic-math\n```\n:::\n\n\n\n\n::: { .solution exercise=\"basic-math\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\n2^5\nsin(pi/4)\nsqrt(2)\n```\n:::\n:::\n\nOne way in which R differs from most programming languages is that it is inherently vectorized. In R, you always work with vectors of numbers rather than with individual values. (A vector is an ordered set of values of the same data type.) Vectors are created with `c(...)`, as in `c(1, 2, 3)`. You can also create vectors of consecutive integers using the colon notation, as in `1:3` or `3:1`. The latter places the integers into the reverse order.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nc(1, 2, 3)\n1:3\n3:1\n```\n:::\n\n\n\n\nTry this out. Make a vector of the integers from 1 to 10. Make a vector of the values 0.25, 0.5, 0.75. Make a vector of the words \"orange\", \"banana\", \"grapefruit\".\n\n\n\n\n::: {.cell exercise='vectors'}\n```{webr}\n#| exercise: vectors\n```\n:::\n\n\n\n\n::: { .solution exercise=\"vectors\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\n1:10\nc(0.25, 0.5, 0.75)\nc(\"orange\", \"banana\", \"grapefruit\")\n```\n:::\n:::\n\nMathematical operations are also vectorized, so you can for example multiply all values in a vector by the same number or calculate multiple square roots at once. You can also do mathematical operations combining two (or more) vectors and the operation will be element-wise. If the numbers of elements don't match you will get a warning but R will still give you a result. However, it's generally best to avoid combining vectors with mismatched lengths, as the results can be non-intuitive.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n5*(1:5)\nsqrt(c(4, 9, 16, 25))\n1:5 + c(1, 1, 2, 2, 2)\n1:5 + c(1, 1, 2, 2) # mismatch in the number of elements\n```\n:::\n\n\n\n\nTry this out. Make a vector of all the squares of the numbers from 1 to 5. Also make a vector of the values 0.25, 0.5, 0.75, by using a vectorized mathematical expression.\n\n\n\n\n::: {.cell exercise='vectors-math'}\n```{webr}\n#| exercise: vectors-math\n```\n:::\n\n\n\n\n::: { .solution exercise=\"vectors-math\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\n(1:5)^2\n(1:3)/4\n```\n:::\n:::\n\nR also has logical values `TRUE` and `FALSE` (written in all capitals). Logical values also are vectorized, and they can be created by vectorized comparisons. This is very important for data analysis tasks.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nc(TRUE, FALSE, FALSE, TRUE)\n(1:10) > 5 \nc(1, 2, 1, 2) == 2\n```\n:::\n\n\n\n\nTry this out. Manually create a vector of logical values. Then create a vector of logical values via comparison.\n\n\n\n\n::: {.cell exercise='logicals'}\n```{webr}\n#| exercise: logicals\n```\n:::\n\n\n\n\n::: { .solution exercise=\"logicals\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nc(TRUE, TRUE, TRUE, FALSE)\n(1:10) <= 5\n```\n:::\n:::\n\nYou can combine vectors of logical values with `&` (logical AND) and `|` (logical OR). You can negate logical values with `!` (logical NOT). \n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n!(c(1, 2, 1, 2) == 2)\nc(TRUE, TRUE) & c(TRUE, FALSE)\nc(FALSE, TRUE) | c(TRUE, FALSE)\n```\n:::\n\n\n\n\nTry this out. Combine some logical vectors with `&` and `|`. Also negate a logical vector.\n\n\n\n\n::: {.cell exercise='logicals2'}\n```{webr}\n#| exercise: logicals2\n```\n:::\n\n\n\n\n::: { .solution exercise=\"logicals2\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\n!c(FALSE, TRUE) & c(TRUE, FALSE)\nc(FALSE, TRUE) | c(TRUE, FALSE)\n```\n:::\n:::\n\n\n## Missing values\n\nR supports the concept of missing values. Missing values are data values that don't exist. This is a common issue in real-world data. For example, consider a scenario where people are asked to fill out a questionaire about various aspects of who they are and where they live, and one question asks about where they were born, and some people simply don't answer that question. The result is a missing value, and we need the ability to express this concept.\n\nIn R, missing values are denoted by `NA`. You can use `NA` as a value for any vector.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nc(1, 2, NA, 4) # missing value in position 3\nc(\"red\", NA, \"green\", NA) # missing values in positions 2 and 4\n```\n:::\n\n\n\nNote that the `NA` indicating a missing value is not enclosed in quotes, even for vectors of words (i.e, character strings).\n\nIn computations, missing values remain missing. You can check for missingness via `is.na()`.\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n5*c(1, 2, NA, 4)\nis.na(c(1, 2, NA, 4))\n```\n:::\n\n\n\n\nTry this out. Make both a numerical and a character vector with some missing values. Also test for the missing positions in one of the vectors you made.\n\n\n\n\n::: {.cell exercise='NA'}\n```{webr}\n#| exercise: NA\n```\n:::\n\n\n\n\n::: { .solution exercise=\"NA\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nc(NA, 1, NA, 1)\nc(\"banana\", NA, \"orange\", NA)\nis.na(c(\"banana\", NA, \"orange\", NA))\n```\n:::\n:::\n\n## Variables and functions\n\nAny data values or objects that you are working with in R can be assigned to variables to be reused later. Assignment in R is expressed with the `<-` operator. (You can also assign with `=` but this is generally discouraged.) If you subsequently just write the variable name by itself R prints out the value corresponding to that variable.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nnames <- c(\"John\", \"Lily\", \"Mark\", \"Anna\")\nnames\nnames == \"Anna\"\nnumbers <- c(1, 4, 5, 2)\n5*numbers\nexp(numbers)\n```\n:::\n\n\n\n\nTry this out. Assign the number 5 to a variable called `foo` and then print the value of `foo`. Then calculate the cosine of this number. \n\n\n\n::: {.cell exercise='variables'}\n```{webr}\n#| exercise: variables\n```\n:::\n\n\n\n\n::: { .solution exercise=\"variables\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nfoo <- 5\nfoo\ncos(foo)\n```\n:::\n:::\n\nIn addition to working with variables, we commonly use and interact with functions in R. Functions are a way to store code and reuse it at a later stage. To call a function (which means to execute the code the function stores), you write the name of the variable storing the function followed by parentheses, as in `sin()` for the sine function. Inside the parentheses we can place values that are called \"arguments,\" as in `sin(0.5)`. These arguments turn into variables that are used inside the function body.\n\nIn R, function arguments are always named, which means you can write the name of the argument when you provide the argument value, as in `sin(x = 0.5)`. This is helpful for functions with many arguments, as without providing the argument names it can be confusing which value gets assigned to which argument. If you don't name the function arguments, then values are assigned to arguments in order (positional matching), similarly to how most other programming languages work.\n\nIn the following example, the function `example_fun()` takes three arguments, `a`, `b`, and `c`, and each argument has a default value that will be used in case the argument is not provided when the function is called. The function then simply prints the values of the arguments. This allows us to explore how argument matching works in R.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n# function definition\nexample_fun <- function(a = \"default a\", b = \"default b\", c = \"default c\") {\n  cat(\"a:\", a, \"\\nb:\", b, \"\\nc:\", c, \"\\n\")\n}\n\n# using the function\nexample_fun()\nexample_fun(1, 2)\nexample_fun(b = 2)\nexample_fun(c = 1, b = 2)\n```\n:::\n\n\n\n\nNow try this out yourself. Using the function `example_fun()` defined above, see what happens when you provide different arguments, positional or named. Do you understand what `example_fun(2, a = 1)` does?\n\n\n\n\n::: {.cell exercise='functions'}\n```{webr}\n#| exercise: functions\nexample_fun(___)\n```\n:::\n\n\n\n\n## Packages\n\nMany R features are provided by extension packages. You need to load those packages with `library()` before you can use them. For example, throughout this class, we make extensive use of the **tidyverse** package and therefore you will see `library(tidyverse)` at the beginning of most worksheets and homework templates. One of the most common problem students encounter in assignments is that they want to use a function from a package but have not properly loaded the package.\n\nNote that we don't normally put the package name in quotes inside the `library()` statement.\n\nUpon loading, some packages write out all sorts of messages. In particular, the **tidyverse** package lists a number of \"conflicts\". This frequently confuses students as they think something has gone wrong. You can just ignore these conflicts. They are expected and they will not interfere with your work in this class.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nlibrary(tidyverse)\n```\n:::\n\n\n\n\nTry out loading a package. Load the package **ggridges**. Then load the package **cowplot**.\n\n\n\n\n::: {.cell exercise='package-loading'}\n```{webr}\n#| exercise: package-loading\n```\n:::\n\n\n\n\n::: { .solution exercise=\"package-loading\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nlibrary(ggridges)\nlibrary(cowplot)\n```\n:::\n:::\n\n## Numerical and logical indexing\n\nR has a variety of ways to extract specific values or subsets of a vector. First, you can extract an individual element by indexing with square brackets. For example, if `x` is a vector, `x[1]` is the first element, `x[2]` is the second element, and so on. Note that in R, the first element of a vector is number 1, not number 0 as it is in most other languages (Python, C, Rust, etc.). You can also extract multiple elements by placing a vector of numeric values inside the square brackets.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nnames <- c(\"John\", \"Lily\", \"Mark\", \"Anna\")\nnames[2]\nnames[1:3]\nnames[c(1, 3)]\n```\n:::\n\n\n\n\nNegative indices *remove* the respective elements.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nnames[-2]\nnames[-(1:3)]\nnames[c(-1, -3)]\n```\n:::\n\n\n\n\nTry this out. Extract the first element from the `names` vector, then extract the last two, then extract all but the first.\n\n\n\n\n::: {.cell exercise='indexing'}\n```{webr}\n#| exercise: indexing\n```\n:::\n\n\n\n\n::: { .solution exercise=\"indexing\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nnames[1]\nnames[c(3, 4)]\nnames[-1]\n```\n:::\n:::\n\nIn addition to numerical indexing, a frequently used indexing approach in R is logical indexing. In logical indexing, you provide inside the square brackets a logical vector that indicates for each element whether you want to keep it (`TRUE`) or not (`FALSE`). The benefit of this indexing approach is that you can combine it with logical statements to extract all elements that meet a specific condition.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nnumbers <- c(1, 7, 4)\nnumbers[c(TRUE, FALSE, TRUE)]\nnumbers[numbers > 5]\n```\n:::\n\n\n\n\nTry this out, by extracting all the even numbers from the numerical vector `1:10`. To test whether a number `x` is even, you can use `x %% 2 == 0`.\n\n\n\n\n::: {.cell exercise='logical-indexing'}\n```{webr}\n#| exercise: logical-indexing\nnumbers <- 1:10\n```\n:::\n\n\n\n\n::: { .solution exercise=\"logical-indexing\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nnumbers <- 1:10\nnumbers[numbers %% 2 == 0]\n```\n:::\n:::\n\n## Data frames\n\nA core concept of R is the data frame, which holds data in tabular form. A data frame is made up of multiple columns that all have the same number of elements. Different columns can be of different types.\n\nThere are a variety of ways to create a data frame. We will usually use the `tibble()` function from the **tidyverse** package.\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\ntibble(\n  name = c(\"John\", \"Lily\", \"Mark\", \"Anna\"),\n  age = c(25, 26, 15, 19),\n  hometown = c(\"Austin\", \"Houston\", NA, \"San Antonio\")\n)\n```\n:::\n\n\n\n\nNote how we can assign names to the columns via named arguments in the `tibble()` function.\n\nTry this out. Create a tibble of your own.\n\n\n\n\n::: {.cell exercise='tibble'}\n```{webr}\n#| exercise: tibble\n```\n:::\n\n\n\n\n\n## Flow control\n\nR has standard flow-control features such as `for` loops and `if`/`else` statements. These are almost never needed in data analysis and therefore I will not cover them here. If you find yourself wanting to use those constructs chances are you are replicating procedural programming patterns you have learned in other languages but that are not the most elegant way to solving a data analysis problem. I would encourage you to think about how to solve your problem using vectorized or functional programming patterns instead. (Functional programming patterns such as `map()` go beyond this basic tutorial but will be covered later in this class.)\n\nA concept closely related to flow control is the `if_else()` function from the **tidyverse** package. With `if_else()`, you can run a comparison at each position in a vector and then create a new vector whose elements depend on the outcome of each comparison.\n\nFor example, we can replace each occurrence of the word \"orange\" by \"citrus\" like so:\n\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\nfruit <- c(\"orange\", \"banana\", \"apple\", \"orange\", \"grape\")\nif_else(fruit == \"orange\", \"citrus\", fruit)\n```\n:::\n\n\n\n\nThe first argument to `if_else()` is the logical condition you want to execute, the second argument is the resulting value if the condition is true, and the third argument is the resulting value if the condition is false.\n\nTry this out. In the following example, replace all numbers greater than 5 with the number 5 in the vector `numbers`.\n\n\n\n\n::: {.cell exercise='if-else'}\n```{webr}\n#| exercise: if-else\nnumbers <- c(10, 2, 4, 7, 6, -1, -8)\nif_else(___)\n```\n:::\n\n\n\n\n::: { .hint exercise=\"if-else\" }\n::: { .callout-tip title=\"Hint\" collapse=\"false\"}\n```r\nnumbers <- c(10, 2, 4, 7, 6, -1, -8)\nif_else(numbers > 5, ___, ___)\n```\n:::\n:::\n\n\n::: { .solution exercise=\"if-else\" }\n::: { .callout-tip title=\"Solution\" collapse=\"false\"}\n```r\nnumbers <- c(10, 2, 4, 7, 6, -1, -8)\nif_else(numbers > 5, 5, numbers)\n```\n:::\n:::\n\n\n",
    "supporting": [
      "intro-to-R_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}