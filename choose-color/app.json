[{"name":"app.R","content":"# To deploy:\n# shinylive::export(\"_choose-color-source\", \"choose-color\")\n\nlibrary(shiny)\nlibrary(shinyjs)\nlibrary(colorspace)\n\n#### UI\ncolor_picker_sidebarPanel <- function() {\n\n    # sidebar with controls to select the color\n    shiny::sidebarPanel(\n        shiny::sliderInput(\"H\", \"Hue\",\n                           min = 0, max = 360, value = 60),\n        shiny::sliderInput(\"C\", \"Chroma\",\n                           min = 0, max = 180, value = 40),\n        shiny::sliderInput(\"L\", \"Luminance\",\n                           min = 0, max = 100, value = 60),\n        shiny::splitLayout(\n            shiny::textInput(\"hexcolor\", \"RGB hex color\", colorspace::hex(colorspace::polarLUV(60, 40, 60))),\n            shiny::div(class = 'form-group shiny-input-container',\n              shiny::actionButton(\"set_hexcolor\", \"Set\")\n            ),\n            cellWidths = c(\"70%\", \"30%\"),\n            cellArgs = list(style = \"vertical-align: bottom;\")\n        ),\n        shiny::p(shiny::HTML(\"<b>Selected color<\/b>\")),\n        shiny::htmlOutput(\"colorbox\"),\n        shiny::withTags(p(style=\"margin-top: 5px; font-weight: bold;\",\"Actions\")),\n        shiny::actionButton(\"color_picker\", \"Pick\"),\n        shiny::actionButton(\"color_unpicker\", \"Unpick\"),\n        shiny::actionButton(\"clear_color_picker\", \"Clear\"),\n        # Disable \"Return to R\" button if running on webserver\n        if ( ! Sys.info()[\"nodename\"] == \"sculptor.uberspace.de\" ) {\n          shiny::actionButton(\"closeapp\",\"Return to R\")\n        },\n        shiny::checkboxInput(\"darkmode\", \"Dark mode\", value = FALSE, width = NULL)\n  \n    )\n}\n\n\ncolor_picker_mainPanel <- function() {\n\n    # ---------------------------------------------------------------\n    # Main shiny panel\n    # ---------------------------------------------------------------\n    shiny::mainPanel(\n\n        shiny::tabsetPanel(type = \"tabs\", id = \"maintabs\",\n        # -----------------------------------------------------------\n        # Shinys Luminance-Chroma plane tab\n        # -----------------------------------------------------------\n            shiny::tabPanel(\"Luminance-Chroma plane\", value = \"lcplane\",\n                shiny::plotOutput(\"LC_plot\", click = \"LC_plot_click\"),\n                shiny::plotOutput(\"Hgrad\",   click = \"Hgrad_click\", height = 50),\n                shiny::plotOutput(\"Cgrad\",   click = \"Cgrad_click\", height = 50),\n                shiny::plotOutput(\"Lgrad\",   click = \"Lgrad_click\", height = 50)\n            ),\n        # -----------------------------------------------------------\n        # Shinys Hue-Chroma plane\n        # -----------------------------------------------------------\n            shiny::tabPanel(\"Hue-Chroma plane\", value = \"hcplane\",\n                shiny::plotOutput(\"HC_plot\", click = \"HC_plot_click\"),\n                shiny::plotOutput(\"Hgrad2\",  click = \"Hgrad_click\", height = 50),\n                shiny::plotOutput(\"Cgrad2\",  click = \"Cgrad_click\", height = 50),\n                shiny::plotOutput(\"Lgrad2\",  click = \"Lgrad_click\", height = 50)\n            ),\n        # -----------------------------------------------------------\n        # Export tab\n        # -----------------------------------------------------------\n            shiny::tabPanel(\"Export\", value = \"export\", icon = shiny::icon(\"download\", lib = \"font-awesome\"),\n                shiny::withTags(div(class = \"hcl\", id = \"hcl-export\",\n                                    shiny::withTags(div(class = \"output-raw\",\n                                                        shiny::htmlOutput(\"exportRAW1\"),\n                                                        shiny::downloadButton(\"downloadRAW1\", \"Download\")\n                    )),\n                    shiny::withTags(div(class = \"output-raw\",\n                                        shiny::htmlOutput(\"exportRAW2\"),\n                                        shiny::downloadButton(\"downloadRAW2\", \"Download\")\n                    )),\n                    shiny::withTags(div(class = \"output-raw\",\n                                        shiny::htmlOutput(\"exportRAW3\"),\n                                        shiny::downloadButton(\"downloadRAW3\", \"Download\")\n                    )),\n                    shiny::withTags(div(class = \"output-raw\",\n                                        shiny::htmlOutput(\"exportRAW4\")\n                    )),\n                    shiny::withTags(div(class = \"end-float\")),\n                    shiny::h3(\"Output\"),\n                    shiny::htmlOutput(\"palette_line_R\"),\n                    shiny::htmlOutput(\"palette_line_matlab\")\n                ))\n            ),\n        # -----------------------------------------------------------\n        # Info tab\n        # -----------------------------------------------------------\n            shiny::tabPanel(\"Info\", value = \"info\", icon = shiny::icon(\"info-circle\", lib = \"font-awesome\"),\n                            #shiny::withTags(shiny::div(class = \"hcl-main\", id = \"hcl-main-help\",\n                            #                           shiny::includeHTML(\"html/info.html\")))\n            )\n        ),\n        shiny::withTags(shiny::div(class = \"end-float\")),\n        shiny::h3(\"Color palette\"),\n        shiny::plotOutput(\"palette_plot\", click = \"palette_click\", height = 30)\n    )\n}\n\n\n# -------------------------------------------------------------------\n# Setting up the UI\n# -------------------------------------------------------------------\nui <- shiny::shinyUI(\n    shiny::fluidPage(\n        shiny::tags$head(\n          #shiny::tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"hclcolorpicker.css\"),\n          #shiny::tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"hclcolorpicker_darkmode.css\")\n        ),\n        shinyjs::useShinyjs(),\n        shiny::div(class = \"version-info\", shiny::htmlOutput(\"version_info\")),\n        shiny::sidebarLayout(\n            # sidebar panel, defined above\n            color_picker_sidebarPanel(),\n\n            # main panel, defined above\n            color_picker_mainPanel()\n        )\n    )\n)\n\n#### Server\nserver <- shiny::shinyServer(function(input, output, session) {\n\n    ##if ( Sys.info()[\"nodename\"] == \"sculptor.uberspace.de\" ) {\n    ##   delay(0, toggleState(\"closeapp\", condition = F))\n    ##}\n\n    picked_color_list <- shiny::reactiveValues(cl=c())\n\n    # ----------------------------------------------------------------\n    # Switch between dark mode (black background) and normal mode\n    # (white background). Also used for the demo plots.\n    # ----------------------------------------------------------------\n    observeEvent(input$darkmode, {\n       if ( ! input$darkmode ) {\n          shinyjs::removeClass(selector = \"body\", class = \"darkmode\")\n       } else {\n          shinyjs::addClass(selector = \"body\", class = \"darkmode\")\n       }\n    })\n\n    # ----------------------------------------------------------------\n    # Clicking on HC plot plane\n    # ----------------------------------------------------------------\n    shiny::observeEvent({input$HC_plot_click}, {\n        # store the old colors\n        coords_old_LUV <- colorspace::coords(as(colorspace::polarLUV(as.numeric(input$L),\n                                             as.numeric(input$C),\n                                             as.numeric(input$H)), \"LUV\"))\n        U    <- input$HC_plot_click$x\n        if (is.null(U)) U <- coords_old_LUV[2L]\n        V    <- input$HC_plot_click$y\n        if (is.null(V)) V <- coords_old_LUV[3L]\n        L    <- input$L\n        coords_HCL <- colorspace::coords(as(colorspace::LUV(L, U, V), \"polarLUV\"))\n        shiny::updateSliderInput(session, \"C\", value = round(coords_HCL[2L]))\n        shiny::updateSliderInput(session, \"H\", value = round(coords_HCL[3L]))\n    })\n\n    # ----------------------------------------------------------------\n    # Clicking on LC plot plane\n    # ----------------------------------------------------------------\n    shiny::observeEvent({input$LC_plot_click}, {\n        # store the old colors\n        Lold <- as.numeric(input$L)\n        Cold <- as.numeric(input$C)\n        C    <- input$LC_plot_click$x\n        if (is.null(C)) C <- Cold\n        L    <- input$LC_plot_click$y\n        if (is.null(L)) L <- Lold\n        shiny::updateSliderInput(session, \"C\", value = round(C))\n        shiny::updateSliderInput(session, \"L\", value = round(L))\n    })\n\n    # ----------------------------------------------------------------\n    # Palette click: event triggered when clicking on the\n    # \"palette of selected colors\".\n    # ----------------------------------------------------------------\n    shiny::observeEvent({input$palette_click}, {\n        x <- input$palette_click$x\n        if ( length(picked_color_list$cl) == 0 ) return()\n        if ( is.null(x) ) return()\n        i <- ceiling(x * length(picked_color_list$cl))\n        col_RGB    <- colorspace::hex2RGB(picked_color_list$cl[i])\n        coords_HCL <- colorspace::coords(as(col_RGB, \"polarLUV\"))\n        shiny::updateSliderInput(session, \"L\", value = round(coords_HCL[1L]))\n        shiny::updateSliderInput(session, \"C\", value = round(coords_HCL[2L]))\n        shiny::updateSliderInput(session, \"H\", value = round(coords_HCL[3L]))\n    })\n\n    # ----------------------------------------------------------------\n    # Clicking on Hue gradient area\n    # ----------------------------------------------------------------\n    shiny::observeEvent({input$Hgrad_click}, {\n        H <- input$Hgrad_click$x\n        if (!is.null(H))\n            shiny::updateSliderInput(session, \"H\", value = round(H))\n    })\n\n    # ----------------------------------------------------------------\n    # Clicking on Luminance gradient area\n    # ----------------------------------------------------------------\n    shiny::observeEvent({input$Lgrad_click}, {\n        L <- input$Lgrad_click$x\n        if (!is.null(L))\n            shiny::updateSliderInput(session, \"L\", value = round(L))\n    })\n\n    # ----------------------------------------------------------------\n    # Clicking on Chroma gradient area\n    # ----------------------------------------------------------------\n    shiny::observeEvent({input$Cgrad_click}, {\n        C <- input$Cgrad_click$x\n        if (!is.null(C))\n          shiny::updateSliderInput(session, \"C\", value = round(C))\n    })\n\n    # ----------------------------------------------------------------\n    # ----------------------------------------------------------------\n    shiny::observeEvent({input$set_hexcolor}, {\n      # only execute this on complete color hex codes\n      if (grepl(\"^#[0123456789ABCDEFabcdef]{6}$\", input$hexcolor)) {\n          col_RGB <- colorspace::hex2RGB(input$hexcolor)\n          coords_HCL <- colorspace::coords(as(col_RGB, \"polarLUV\"))\n          shiny::updateSliderInput(session, \"L\", value = round(coords_HCL[1L]))\n          shiny::updateSliderInput(session, \"C\", value = round(coords_HCL[2L]))\n          shiny::updateSliderInput(session, \"H\", value = round(coords_HCL[3L]))\n      }\n    })\n\n\n    # ----------------------------------------------------------------\n    # save color code\n    # ----------------------------------------------------------------\n    shiny::observeEvent(input$color_picker, {\n        # cannot rely on hex color in text-input field, so recalculate from set H, C, L values\n        hexcolor <- colorspace::hex(colorspace::polarLUV(as.numeric(input$L), as.numeric(input$C), as.numeric(input$H)))\n        # only add color if it's not already in the list\n        if ( ! is.na(hexcolor) && ! hexcolor %in% picked_color_list$cl) {\n            picked_color_list$cl <- c(picked_color_list$cl, hexcolor)\n        } else {\n            showNotification(\"No valid color selected.\")\n        }\n        if ( length(picked_color_list$cl) == 0 ) return()\n        generateExport(output, picked_color_list$cl) \n    })\n\n    # ----------------------------------------------------------------\n    # undo pick color\n    # ----------------------------------------------------------------\n    shiny::observeEvent(input$color_unpicker, {\n        if (input$hexcolor %in% picked_color_list$cl)\n            picked_color_list$cl <- picked_color_list$cl[picked_color_list$cl != input$hexcolor]\n        #} else {\n        #  # It's a better user interface to leave the list alone if the color is not in the list\n        #  # picked_color_list$cl <- head(picked_color_list$cl,-1)\n        #}\n    })\n\n    # ----------------------------------------------------------------\n    # clear saved color code\n    # ----------------------------------------------------------------\n    shiny::observeEvent(input$clear_color_picker, {\n        picked_color_list$cl <- c()\n    })\n\n    # ----------------------------------------------------------------\n    # ----------------------------------------------------------------\n    shiny::observe({\n        shiny::updateTextInput(session, \"hexcolor\",\n                               value = colorspace::hex(colorspace::polarLUV(as.numeric(input$L),\n                                                    as.numeric(input$C),\n                                                    as.numeric(input$H))))\n    })\n\n    # ----------------------------------------------------------------\n    # ----------------------------------------------------------------\n    output$colorbox <- shiny::renderUI({\n        shiny::tags$div(style=paste0(\"width: 100%; height: 40px; \",\n                                     \"border: 1px solid rgba(0, 0, 0, .2); background: \",\n                     colorspace::hex(colorspace::polarLUV(as.numeric(input$L),\n                                  as.numeric(input$C),\n                                  as.numeric(input$H))), \";\"))\n    })\n\n    # generate HC plot with given inputs\n    output$HC_plot <- shiny::renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_hue_chroma_plot(as.numeric(input$L),\n                                     as.numeric(input$C),\n                                     as.numeric(input$H))\n    })\n\n    # generate LC plot with given inputs\n    output$LC_plot <- shiny::renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_luminance_chroma_plot(as.numeric(input$L),\n                                           as.numeric(input$C),\n                                           as.numeric(input$H))\n    })\n\n\n    output$Hgrad <- shiny::renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_H_gradient(as.numeric(input$L),\n                                as.numeric(input$C),\n                                as.numeric(input$H))\n    })\n\n    output$Hgrad2 <- shiny::renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_H_gradient(as.numeric(input$L),\n                                as.numeric(input$C),\n                                as.numeric(input$H))\n    })\n\n    output$Cgrad <- shiny::renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_C_gradient(as.numeric(input$L),\n                                as.numeric(input$C),\n                                as.numeric(input$H))\n    })\n\n    output$Cgrad2 <- shiny::renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_C_gradient(as.numeric(input$L),\n                                as.numeric(input$C),\n                                as.numeric(input$H))\n    })\n\n\n    output$Lgrad <- shiny::renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_L_gradient(as.numeric(input$L),\n                                as.numeric(input$C),\n                                as.numeric(input$H))\n    })\n\n    output$Lgrad2 <- shiny::renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_L_gradient(as.numeric(input$L),\n                                as.numeric(input$C),\n                                as.numeric(input$H))\n    })\n\n    # generate palette plot with given hex code\n    output$palette_plot <- shiny::renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        pal_plot(picked_color_list$cl)\n    })\n\n    # add R color code line\n    output$palette_line_R <- shiny::renderText({\n        if (length(picked_color_list$cl) != 0) {\n            color_list  <- picked_color_list$cl\n            color_list  <- paste(color_list, collapse = \"', '\")\n            color_string <- paste(\"<code>colors <- c('\", color_list, \"')<\/code>\", sep = '')\n            sprintf(\"<b style=\\\"display:block;margin-top:5px\\\">R style color vector<\/b>%s\", color_string)\n        } else {\n            paste(\"Currently no colors picked. Go to the \\\"<b>Luminance-Chroma plane<\/b>\\\"\",\n                  \"or the \\\"<b>Hue-Chroma plane<\/b>\\\" tab, define a color,\",\n                  \"and press <b>pick<\/b> to add the color to your selection.\")\n        }\n    })\n    # Add matlab style output\n    output$palette_line_matlab <- shiny::renderText({\n        if (length(picked_color_list$cl) != 0){\n            # Convert colors to RGB for matlab\n            color_string <- sprintf(\"<code>colors = [%s]<\/code>\",\n                   paste0(base::apply(colorspace::hex2RGB(picked_color_list$cl)@coords,1, function(x)\n                   sprintf(\"%.3f,%.3f,%.3f\",x[1L],x[2L],x[3L])),collapse=\"; \"))\n            sprintf(\"<b style=\\\"display:block;margin-top:5px\\\">matlab style color vector<\/b>%s\", color_string)\n        }\n    })\n\n    # ----------------------------------------------------------------\n    # Return data to R-console\n    # ----------------------------------------------------------------\n    shiny::observeEvent(input$closeapp,\n        shiny::stopApp(invisible(picked_color_list$cl))\n    );\n\n    # ----------------------------------------------------------------\n    # Version information lower right corner\n    # ----------------------------------------------------------------\n    output$version_info <- renderText(sprintf(\"<a href=\\\"%s\\\">R colorspace %s<\/a>\",\n                                      \"https://cran.r-project.org/package=colorspace\",\n                                      packageVersion(\"colorspace\")))\n\n\n\n    # downloadHandler() takes two arguments, both functions.\n    # The content function is passed a filename as an argument, and\n    #   it should write out data to that filename.\n    getRGB <- function(int=FALSE) {\n        colors <- picked_color_list$cl\n        if ( int ) { scale = 255; digits = 0 } else { scale = 1; digits = 3 }\n        RGB <- round(attr(colorspace::hex2RGB(colors), \"coords\")*scale, digits)\n        return(RGB)\n    }\n    getHCL <- function() {\n        HCL <- colorspace::coords(as(colorspace::hex2RGB(picked_color_list$cl), \"polarLUV\"))\n        HCL <- round(HCL)[,c(\"H\",\"C\",\"L\")]\n        if ( is.null(nrow(HCL)) ) HCL <- as.matrix(t(HCL))\n        return(HCL)\n    }\n    output$downloadRAW1 <- downloadHandler(\n        file <- \"colormap_HCL.txt\",\n        content = function(file) {\n            if ( length(picked_color_list$cl) > 0 ) {\n                write.table(getHCL(),  file,  sep = \",\",\n                            col.names = TRUE,  row.names = FALSE)\n            } else {\n                write(file = file, \"No colors selected.\")\n            }\n        }\n    )\n    output$downloadRAW2 <- downloadHandler(\n        file <- \"colormap_RGB.txt\",\n        content = function(file) {\n            if ( length(picked_color_list$cl) > 0 ) {\n                write.table(getRGB(TRUE),  file,  sep = \",\", \n                            col.names = TRUE,  row.names = FALSE)\n            } else {\n                write(file = file, \"No colors selected.\")\n            }\n        }\n    )\n    output$downloadRAW3 <- downloadHandler(\n        file <- \"colormap_hex.txt\",\n        content = function(file) {\n            if ( length(picked_color_list$cl) > 0 ) {\n                write.table(picked_color_list$cl,  file,  sep = \",\", \n                            col.names = FALSE, row.names = FALSE)\n            } else {\n                write(file = file, \"No colors selected.\")\n            }\n        }\n    )\n\n})\n\n\ncolor_picker_hue_chroma_plot <- function(L = 75, C = 20, H = 0, n = 200) {\n\n    Cmax  <- max(colorspace::max_chroma(0:360, L))\n    Vmax  <- Cmax\n    Umax  <- Cmax\n    U     <- seq(-Umax, Umax, length.out = n)\n    V     <- seq(Vmax, -Vmax, length.out = n)\n    grid  <- expand.grid(U = U, V = V)\n    image <- matrix(colorspace::hex(colorspace::LUV(L, grid$U, grid$V)), nrow = n, byrow = TRUE)\n    grob  <- grid::rasterGrob(image)\n\n    sel_col <- colorspace::polarLUV(L, C, H) # selected color in polar LUV\n    sel_pt  <- colorspace::coords(as(sel_col, \"LUV\")) # coordinates of selected point in LUV\n    df_sel  <- data.frame(U = sel_pt[2L], V = sel_pt[3L])\n\n    grid$hex <- as.vector(t(image))\n    limits   <- lapply(na.omit(grid), function(x)\n                if ( ! is.numeric(x) ) { return(NULL) } else { max(abs(x))*c(-1,1) } )\n    par(mar = c(3, 3, 1, 1))\n    with(grid, graphics::plot(V ~ U, type=\"n\", bty = \"n\", axes = FALSE,\n                              xaxs = \"i\", yaxs = \"i\", asp = 1, xlim=limits$U, ylim=limits$V))\n    graphics::abline(h = seq(-200,200,by=25), v = seq(-200,200,by=25), col = \"gray80\")\n    graphics::axis(side = 1, at = seq(-200,200,by=50), col = NA, col.ticks = 1)\n    graphics::axis(side = 2, at = seq(-200,200,by=50), col = NA, col.ticks = 1)\n    graphics::points(grid$V ~ grid$U, col = grid$hex, pch = 19)\n\n    # Selected color\n    graphics::points(sel_pt[1,\"V\"] ~ sel_pt[1,\"U\"], cex = 2)\n    sel_radius <- sqrt(sum(sel_pt[1, c(\"U\", \"V\")]^2))\n    graphics::lines(sin(seq(0, 2 * pi, length.out = 300)) * sel_radius,\n                    cos(seq(0, 2 * pi, length.out = 300)) * sel_radius, col = \"gray40\")\n\n    # Box\n    graphics::box(col = \"gray40\")\n\n}\n\ncolor_picker_luminance_chroma_plot <- function(L = 75, C = 20, H = 0, n = 200) {\n\n    Cmax    <- max(C + 5, 150)\n    Cseq    <- seq(0, Cmax, length.out = n)\n    Lseq    <- seq(100, 0, length.out = n)\n    grid    <- expand.grid(C = Cseq, L = Lseq)\n    # Remove points with L == 0 & C > 0\n    grid[which(grid$L == 0 & grid$C > 0),] <- NA\n    image   <- matrix(colorspace::hex(colorspace::polarLUV(grid$L, grid$C, H)), nrow = n, byrow = TRUE)\n    grob    <- grid::rasterGrob(image, width = 1, height = 1)\n\n    sel_col <- colorspace::polarLUV(L, C, H) # selected color in polar LUV\n    df_sel  <- data.frame(C = C, L = L)\n\n    grid$hex <- as.vector(t(image))\n    limits   <- with(na.omit(grid), list( L = c(0,100), C = c(0,max(C))))\n    par( mar = c(3, 3, 1, 1) )\n    with( grid, graphics::plot(L ~ C, type=\"n\", bty = \"n\", axes = FALSE,\n                               asp = 1, xaxs = \"i\", yaxs = \"i\", xlim=limits$C, ylim=limits$L))\n    graphics::abline(h = seq(-200,200,by=25), v = seq(-200,200,by=25), col = \"gray80\")\n    graphics::axis(side = 1, at = seq(limits$C[1L],limits$C[2L],by=25), col = NA, col.ticks = 1)\n    graphics::axis(side = 2, at = seq(limits$L[1L],limits$L[2L],by=25), col = NA, col.ticks = 1)\n    graphics::points(grid$L ~ grid$C, col = grid$hex, pch = 19 )\n    # Selected color\n    graphics::points(df_sel[1,\"L\"] ~ df_sel[1,\"C\"], cex = 2)\n    # Box\n    graphics::box(col = \"gray40\")\n\n}\n\n# Helper function to draw the color bar (gradient's).\n# Input \\code{seq} has to be numeric, sequence of values\n# along the color bar dimension. Cols is an object of\n# NA's and hex colors which can be converted to a vector.\n# Typically a matrix. Length of \\code{cols} has to be equal to\n# length of \\code{seq}.\nplot_color_gradient <- function( seq, cols, sel, ylab = NA, ticks ) {\n\n    par(mar = c(2, 2, .1, 1))\n    # Compute args\n    dx   <- 0.5 * median(diff(seq))\n    seq  <- seq(min(seq), max(seq), length.out=length(cols))\n    args <- list(ybottom = rep(0,length(cols)), ytop = rep(1,length(cols)))\n    args$xleft <- seq - dx;          args$xright <- seq + dx\n    args$col   <- as.vector(cols);   args$border <- NA\n    # Create color bar\n    graphics::plot(NA, ylim = c(0, 1), xlim = range(seq), xaxs = \"i\", yaxs = \"i\",\n                   xlab = NA, ylab = NA, bty = \"n\", axes = FALSE)\n    do.call(\"rect\", args)\n    if ( ! is.na(ylab) )   graphics::mtext(side = 2, line = 0.5, ylab, las = 2)\n    if ( missing(ticks)  ) ticks <- base::pretty(seq)\n    graphics::points(sel, 0.5, cex = 2)\n    graphics::axis(side = 1, at = ticks, col = NA, col.ticks = 1)\n    graphics::box(col = \"gray40\")\n\n}\n\ncolor_picker_C_gradient <- function(L = 75, C = 20, H = 0, n = 100) {\n\n    Cmax    <- max(C + 5, 150)\n    Cseq    <- seq(0, Cmax, length.out = n)\n    image   <- matrix(colorspace::hex(colorspace::polarLUV(L, Cseq, H)), nrow = 1, byrow = TRUE)\n    grob    <- grid::rasterGrob(image, width = 1, height = 1)\n\n    sel_col <- colorspace::hex(colorspace::polarLUV(L, C, H))\n    df_sel  <- data.frame(C = C, H = H, L = L, y = 0)\n\n    # Craw color gradient/color bar\n    plot_color_gradient(Cseq, image, df_sel$C, \"C\")\n\n}\n\ncolor_picker_H_gradient <- function(L = 75, C = 20, H = 0, n = 100) {\n\n    Hseq = seq(0, 360, length.out = n)\n    image <- matrix(colorspace::hex(colorspace::polarLUV(L, C, Hseq)), nrow = 1, byrow = TRUE)\n    grob <- grid::rasterGrob(image, width = 1, height = 1)\n\n    sel_col <- colorspace::hex(colorspace::polarLUV(L, C, H))\n    df_sel <- data.frame(C = C, H = H, L = L, y = 0)\n\n    # Craw color gradient/color bar\n    plot_color_gradient(Hseq, image, df_sel$H, \"H\", seq(0,360,by=45))\n}\n\ncolor_picker_L_gradient <- function(L = 75, C = 20, H = 0, n = 100) {\n\n    Lseq = seq(0, 100, length.out = n)\n    image <- matrix(colorspace::hex(colorspace::polarLUV(Lseq, C, H)), nrow = 1, byrow = TRUE)\n    if ( C > 0 ) image[1,1] <- \"#ffffff\"\n    grob <- grid::rasterGrob(image, width = 1, height = 1)\n\n    sel_col <- colorspace::hex(colorspace::polarLUV(L, C, H))\n    df_sel <- data.frame(C = C, H = H, L = L, y = 0)\n\n    # Craw color gradient/color bar\n    plot_color_gradient(Lseq, image, df_sel$L, \"L\")\n}\n\npal_plot <- function(colors) {\n\n    # Base plot\n    graphics::par(mai = rep(0,4), mar = rep(0,4))\n    graphics::plot(0, 0, type = \"n\", xlim = c(0, 1), ylim = c(0, 1),\n                   xaxs = \"i\", yaxs = \"i\", axes = FALSE, xlab = \"\", ylab=\"\")\n\n    # convert colors to hex and find luminance for each\n    n <- length(colors)\n    if ( n == 0 ) {\n        text(0, 0.5, pos = 4, col = \"#BFBEBD\", \"No colors selected\")\n    } else {\n        col      <- colorspace::hex2RGB(colors)\n        # Convert to HCL to define the text color\n        HCL <- as(colorspace::hex2RGB(colors), \"polarLUV\")\n        text_col <- cursor_color(HCL@coords[, 1L])\n        # Calculate rectangle width/position\n        if ( n == 1 ) {\n            w = 1; x = 0\n        } else {\n            w <- 0.95 / n\n            x <- seq(0, 1, by = w + 0.05 / (n - 1))\n        }\n        graphics::rect(x, 0, x + w, 1, col = colors, border = NA)\n        graphics::text(x + w / 2., .5, labels = colors, col = text_col, cex = 1.2)\n        #graphics::rect((0:(n-1)+.1)/n, 0, (1:n-.1)/n, 1, col = colors, border = NA)\n        #graphics::text((0:(n-1)+.5)/n, .5, labels = colors, col = text_col, cex = 1.2)\n    }\n\n}\n\ncursor_color <- function(L) ifelse(L >= 50, \"#000000\", \"#FFFFFF\")\n\n# ----------------------------------------------------------------\n# Export colors: generate export content\n# ----------------------------------------------------------------\ngenerateExport <- function(output, colors) {\n\n   # Setting \"NA\" colors if fixup=FALSE to white and\n   # store the indizes on colors.na. Replacement required\n   # to be able to convert hex->RGB, index required to\n   # create proper output (where NA values should be displayed).\n   colors.na <- which(is.na(colors))\n   colors[is.na(colors)] <- \"#ffffff\"\n\n   # --------------------------\n   # RAW\n   # --------------------------\n   # Generate RGB coordinates\n   sRGB <- colorspace::hex2RGB(colors)\n   RGB  <- attr( sRGB, \"coords\" )\n   HCL  <- round(attr( as( sRGB, \"polarLUV\" ), \"coords\" ))\n\n   # Generate output string\n   append <- function(x,new) c(x,new)\n   raw1 <- raw2 <- raw3 <- raw4 <- list()\n   # RGB 0-1\n   raw1 <- append(raw1, \"<div style=\\\"clear: both;\\\">\")\n   raw1 <- append(raw1, \"<span class=\\\"output-raw\\\">\")\n   raw1 <- append(raw1, \"HCL values\")\n   for ( i in 1:nrow(HCL) )\n      raw1 <- append(raw1,ifelse(i %in% colors.na,\n                     gsub(\" \", \"&nbsp;\", sprintf(\"<code>%5s %5s %5s<\/code>\", \"NA\", \"NA\", \"NA\")),\n                     gsub(\" \", \"&nbsp;\", sprintf(\"<code>%4d %4d %4d<\/code>\", HCL[i,\"H\"], HCL[i,\"C\"], HCL[i,\"L\"]))))\n   raw1 <- append(raw1, \"<\/span>\")\n   # RGB 0-255\n   raw2 <- append(raw2, \"<span class=\\\"output-raw\\\">\")\n   raw2 <- append(raw2, \"RGB values [0-255]\")\n   RGB  <- round(RGB * 255)\n   for ( i in 1:nrow(RGB) )\n      raw2 <- append(raw2,ifelse(i %in% colors.na,\n                     gsub(\" \", \"&nbsp;\", sprintf(\"<code>%4s %4s %4s<\/code>\", \"NA\", \"NA\", \"NA\")),\n                     gsub(\" \", \"&nbsp;\", sprintf(\"<code>%4d %4d %4d<\/code>\", RGB[i,1], RGB[i,2], RGB[i,3]))))\n   raw2 <- append(raw2,\"<\/span>\")\n   # HEX colors\n   raw3 <- append(raw3,\"<span class=\\\"output-raw\\\">\")\n   raw3 <- append(raw3,\"HEX colors, no alpha\")\n   for ( i in seq_along(colors) )\n      raw3 <- append(raw3,ifelse(i %in% colors.na,\n                     gsub(\" \",\"&nbsp;\",sprintf(\"<code>%7s<\/code>\",\"NA\")),\n                     sprintf(\"<code>%s<\/code>\",colors[i])))\n   raw3 <- append(raw3, \"<\/span>\")\n   # Color boxes (visual bar) \n   raw4 <- append(raw4, \"<span class=\\\"output-raw\\\">\")\n   raw4 <- append(raw4, \"Color Map\")\n   for ( col in colors )\n      raw4 <- append(raw4, sprintf(\"<cbox style='background-color: %s'><\/cbox>\", col))\n   raw4 <- append(raw4, \"<\/span>\")\n   raw4 <- append(raw4, \"<\/div>\")\n\n   output$exportRAW1 <- renderText(paste(raw1, collapse = \"\\n\"))\n   output$exportRAW2 <- renderText(paste(raw2, collapse = \"\\n\"))\n   output$exportRAW3 <- renderText(paste(raw3, collapse = \"\\n\"))\n   output$exportRAW4 <- renderText(paste(raw4, collapse = \"\\n\"))\n\n   \n   # -----------------------------\n   # For GrADS\n   # -----------------------------\n   gastr <- c()\n   gastr <- append(gastr, \"<div class=\\\"output-grads\\\">\")\n   gastr <- append(gastr, \"<comment>** Define colors palette<\/comment>\") \n   if ( length(colors.na) > 0 )\n      gastr <- append(gastr, \"<comment>** WARNING undefined colors in color map!<\/comment>\") \n   for ( i in 1:nrow(RGB) ) {\n      gastr <- append(gastr,ifelse(i %in% colors.na,\n                      gsub(\" \", \"&nbsp;\",sprintf(\"<code>'set rgb %02d %4s %4s %4s'<\/code>\",\n                                           i + 19, \"NA\", \"NA\", \"NA\")),\n                      gsub(\" \", \"&nbsp;\",sprintf(\"<code>'set rgb %02d %4d %4d %4d'<\/code>\",\n                                           i + 19, RGB[i,1], RGB[i,2], RGB[i,3]))))\n   }\n   gastr <- append(gastr, sprintf(\"<code>'set ccols %s'<\/code>\",\n                                  paste(1:nrow(RGB) + 19, collapse = \" \")))\n   gastr <- append(gastr, sprintf(\"<code>'set clevs %s'<\/code>\",\n                                  paste(round(seq(0, 100, length.out=nrow(RGB) - 1), 1), collapse=\" \")))\n   gastr <- append(gastr, \"<comment>** Open data set via DODS<\/comment>\")\n   gastr <- append(gastr, \"<comment>** Open data set via DODS<\/comment>\")\n   gastr <- append(gastr, strftime(Sys.Date() - 1, \"<code>'sdfopen http://nomads.ncep.noaa.gov:9090/dods/gfs_1p00/gfs%Y%m%d/gfs_1p00_00z_anl'<\/code>\"))\n   output$exportGrADS <- renderText(paste(gastr, collapse = \"\\n\"))\n\n   # -----------------------------\n   # For Python\n   # -----------------------------\n   pystr <- c()\n   pystr <- append(pystr, \"<div class=\\\"output-python\\\">\")\n   pystr <- append(pystr, \"<comment>## Define choosen color palette first<\/comment>\") \n   pystr <- append(pystr, \"<comment>## WARNING undefined colors in color map!<\/comment>\") \n   pycolors <- sprintf(\"\\\"%s\\\"\", colors)\n   if ( length(colors.na) > 0 ) pycolors[colors.na] <- \"None\"\n   pystr <- append(pystr, sprintf(\"<code>colors = (%s)<\/code>\",\n                   paste(sprintf(\"%s\", pycolors), collapse = \",\")))\n   pystr <- append(pystr, \"<\/div>\")\n\n   output$exportPython <- renderText(paste(pystr, collapse = \"\\n\"))\n\n   # -----------------------------\n   # For Matlab\n   # -----------------------------\n   RGB  <- attr(colorspace::hex2RGB(colors),\"coords\")\n   mstr <- c()\n   mstr <- append(mstr, \"<div class=\\\"output-matlab\\\">\")\n   mstr <- append(mstr, \"<comment>%% Define rgb matrix first (matrix size ncolors x 3)<\/comment>\")\n   if ( length(colors.na) > 0 )\n      mstr <- append(mstr, \"<comment>%% WARNING undefined colors in color map!<\/comment>\")\n   vardef <- \"colors = [\"\n   for ( i in 1:nrow(RGB) ) {\n      if ( i == 1 )             { pre <- vardef; post <- \";\" }\n      else if ( i < nrow(RGB) ) { pre <- paste(rep(\" \", nchar(vardef)), collapse = \"\"); post <- \";\" }\n      else                      { pre <- paste(rep(\" \", nchar(vardef)), collapse = \"\"); post <- \"]\" }\n      if ( i %in% colors.na ) {\n         tmp <- sprintf(\"<code>%s%5s,%5s,%5s%s<\/code>\",\n                        pre, \"NaN\", \"NaN\", \"NaN\", post)\n      } else {\n         tmp <- sprintf(\"<code>%s%5.3f,%5.3f,%5.3f%s<\/code>\",\n                        pre, RGB[i, 1], RGB[i, 2], RGB[i, 3], post)\n      }\n      mstr <- append(mstr, gsub(\" \", \"&nbsp;\", tmp))\n   }\n   mstr <- append(mstr, \"<\/div>\")\n\n   output$exportMatlab <- renderText(paste(mstr, collapse=\"\\n\"))\n\n}\n\nshiny::shinyApp(ui, server)\n\n","type":"text"}]
