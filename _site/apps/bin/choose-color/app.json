[{"name":"app.R","content":"# To test in regular R session:\n# shiny::shinyAppDir(\"apps/src/choose-color\")\n#\n# To deploy:\n# shinylive::export(\"apps/src/choose-color\", \"apps/bin/choose-color\")\n# file.copy(from=\"apps/src/choose-color/hclcolorpicker.css\", to=\"apps/bin/choose-color\") \n# file.copy(from=\"apps/src/choose-color/hclcolorpicker_darkmode.css\", to=\"apps/bin/choose-color\") \n\n\n#library(shiny)\n#library(shinyjs)\nlibrary(colorspace)\n\n#### UI\ncolor_picker_sidebarPanel <- function() {\n\n    # sidebar with controls to select the color\n    sidebarPanel(\n        sliderInput(\"H\", \"Hue\",\n                           min = 0, max = 360, value = 60),\n        sliderInput(\"C\", \"Chroma\",\n                           min = 0, max = 180, value = 40),\n        sliderInput(\"L\", \"Luminance\",\n                           min = 0, max = 100, value = 60),\n        splitLayout(\n            textInput(\"hexcolor\", \"RGB hex color\", colorspace::hex(colorspace::polarLUV(60, 40, 60))),\n            div(class = 'form-group shiny-input-container',\n              actionButton(\"set_hexcolor\", \"Set\")\n            ),\n            cellWidths = c(\"70%\", \"30%\"),\n            cellArgs = list(style = \"vertical-align: bottom;\")\n        ),\n        p(HTML(\"<b>Selected color<\/b>\")),\n        htmlOutput(\"colorbox\"),\n        withTags(p(style=\"margin-top: 5px; font-weight: bold;\",\"Actions\")),\n        actionButton(\"color_picker\", \"Pick\"),\n        actionButton(\"color_unpicker\", \"Unpick\"),\n        actionButton(\"clear_color_picker\", \"Clear\"),\n        checkboxInput(\"darkmode\", \"Dark mode\", value = FALSE, width = NULL)\n  \n    )\n}\n\n\ncolor_picker_mainPanel <- function() {\n\n    # ---------------------------------------------------------------\n    # Main shiny panel\n    # ---------------------------------------------------------------\n    mainPanel(\n\n        tabsetPanel(type = \"tabs\", id = \"maintabs\",\n        # -----------------------------------------------------------\n        # Shinys Luminance-Chroma plane tab\n        # -----------------------------------------------------------\n            tabPanel(\"Luminance-Chroma plane\", value = \"lcplane\",\n                plotOutput(\"LC_plot\", click = \"LC_plot_click\"),\n                plotOutput(\"Hgrad\",   click = \"Hgrad_click\", height = 50),\n                plotOutput(\"Cgrad\",   click = \"Cgrad_click\", height = 50),\n                plotOutput(\"Lgrad\",   click = \"Lgrad_click\", height = 50)\n            ),\n        # -----------------------------------------------------------\n        # Shinys Hue-Chroma plane\n        # -----------------------------------------------------------\n            tabPanel(\"Hue-Chroma plane\", value = \"hcplane\",\n                plotOutput(\"HC_plot\", click = \"HC_plot_click\"),\n                plotOutput(\"Hgrad2\",  click = \"Hgrad_click\", height = 50),\n                plotOutput(\"Cgrad2\",  click = \"Cgrad_click\", height = 50),\n                plotOutput(\"Lgrad2\",  click = \"Lgrad_click\", height = 50)\n            ),\n        # -----------------------------------------------------------\n        # Export tab\n        # -----------------------------------------------------------\n            tabPanel(\"Export\", value = \"export\", icon = icon(\"download\", lib = \"font-awesome\"),\n                withTags(\n                  div(class = \"hcl\", id = \"hcl-export\",\n                    withTags(div(class = \"output-raw\",\n                                        htmlOutput(\"exportRAW1\"),\n                                        downloadButton(\"downloadRAW1\", \"Download\")\n                    )),\n                    withTags(div(class = \"output-raw\",\n                                        htmlOutput(\"exportRAW2\"),\n                                        downloadButton(\"downloadRAW2\", \"Download\")\n                    )),\n                    withTags(div(class = \"output-raw\",\n                                        htmlOutput(\"exportRAW3\"),\n                                        downloadButton(\"downloadRAW3\", \"Download\")\n                    )),\n                    withTags(div(class = \"output-raw\",\n                                        htmlOutput(\"exportRAW4\")\n                    )),\n                    withTags(div(class = \"end-float\")),\n                    h3(\"Output\"),\n                    htmlOutput(\"palette_line_R\"),\n                    htmlOutput(\"palette_line_matlab\")\n                ))\n            ),\n        # -----------------------------------------------------------\n        # Info tab\n        # -----------------------------------------------------------\n            tabPanel(\"Info\", value = \"info\", icon = icon(\"info-circle\", lib = \"font-awesome\"),\n                            withTags(div(class = \"hcl-main\", id = \"hcl-main-help\",\n                                                       includeHTML(\"info.html\")))\n            )\n        ),\n        withTags(div(class = \"end-float\")),\n        h3(\"Color palette\"),\n        plotOutput(\"palette_plot\", click = \"palette_click\", height = 30)\n    )\n}\n\n\n# -------------------------------------------------------------------\n# Setting up the UI\n# -------------------------------------------------------------------\nui <- shinyUI(\n    fluidPage(\n        tags$head(\n          # need to write ../hclcolorpicker.css due to way shiny live arranges files (places the app into a randomly-named subdir)\n          tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"../hclcolorpicker.css\"),\n          tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"../hclcolorpicker_darkmode.css\")\n        ),\n        shinyjs::useShinyjs(),\n        #div(class = \"version-info\", htmlOutput(\"version_info\")),\n        sidebarLayout(\n            # sidebar panel, defined above\n            color_picker_sidebarPanel(),\n\n            # main panel, defined above\n            color_picker_mainPanel()\n        )\n    )\n)\n\n#### Server\nserver <- shinyServer(function(input, output, session) {\n    picked_color_list <- reactiveValues(cl=c())\n\n    # ----------------------------------------------------------------\n    # Switch between dark mode (black background) and normal mode\n    # (white background). Also used for the demo plots.\n    # ----------------------------------------------------------------\n    observeEvent(input$darkmode, {\n       if ( !input$darkmode ) {\n          shinyjs::removeClass(selector = \"body\", class = \"darkmode\")\n       } else {\n          shinyjs::addClass(selector = \"body\", class = \"darkmode\")\n       }\n    })\n\n    # ----------------------------------------------------------------\n    # Clicking on HC plot plane\n    # ----------------------------------------------------------------\n    observeEvent({input$HC_plot_click}, {\n        # store the old colors\n        coords_old_LUV <- colorspace::coords(as(colorspace::polarLUV(as.numeric(input$L),\n                                             as.numeric(input$C),\n                                             as.numeric(input$H)), \"LUV\"))\n        U    <- input$HC_plot_click$x\n        if (is.null(U)) U <- coords_old_LUV[2L]\n        V    <- input$HC_plot_click$y\n        if (is.null(V)) V <- coords_old_LUV[3L]\n        L    <- input$L\n        coords_HCL <- colorspace::coords(as(colorspace::LUV(L, U, V), \"polarLUV\"))\n        updateSliderInput(session, \"C\", value = round(coords_HCL[2L]))\n        updateSliderInput(session, \"H\", value = round(coords_HCL[3L]))\n    })\n\n    # ----------------------------------------------------------------\n    # Clicking on LC plot plane\n    # ----------------------------------------------------------------\n    observeEvent({input$LC_plot_click}, {\n        # store the old colors\n        Lold <- as.numeric(input$L)\n        Cold <- as.numeric(input$C)\n        C    <- input$LC_plot_click$x\n        if (is.null(C)) C <- Cold\n        L    <- input$LC_plot_click$y\n        if (is.null(L)) L <- Lold\n        updateSliderInput(session, \"C\", value = round(C))\n        updateSliderInput(session, \"L\", value = round(L))\n    })\n\n    # ----------------------------------------------------------------\n    # Palette click: event triggered when clicking on the\n    # \"palette of selected colors\".\n    # ----------------------------------------------------------------\n    observeEvent({input$palette_click}, {\n        x <- input$palette_click$x\n        if ( length(picked_color_list$cl) == 0 ) return()\n        if ( is.null(x) ) return()\n        i <- ceiling(x * length(picked_color_list$cl))\n        col_RGB    <- colorspace::hex2RGB(picked_color_list$cl[i])\n        coords_HCL <- colorspace::coords(as(col_RGB, \"polarLUV\"))\n        updateSliderInput(session, \"L\", value = round(coords_HCL[1L]))\n        updateSliderInput(session, \"C\", value = round(coords_HCL[2L]))\n        updateSliderInput(session, \"H\", value = round(coords_HCL[3L]))\n    })\n\n    # ----------------------------------------------------------------\n    # Clicking on Hue gradient area\n    # ----------------------------------------------------------------\n    observeEvent({input$Hgrad_click}, {\n        H <- input$Hgrad_click$x\n        if (!is.null(H))\n            updateSliderInput(session, \"H\", value = round(H))\n    })\n\n    # ----------------------------------------------------------------\n    # Clicking on Luminance gradient area\n    # ----------------------------------------------------------------\n    observeEvent({input$Lgrad_click}, {\n        L <- input$Lgrad_click$x\n        if (!is.null(L))\n            updateSliderInput(session, \"L\", value = round(L))\n    })\n\n    # ----------------------------------------------------------------\n    # Clicking on Chroma gradient area\n    # ----------------------------------------------------------------\n    observeEvent({input$Cgrad_click}, {\n        C <- input$Cgrad_click$x\n        if (!is.null(C))\n          updateSliderInput(session, \"C\", value = round(C))\n    })\n\n    # ----------------------------------------------------------------\n    # ----------------------------------------------------------------\n    observeEvent({input$set_hexcolor}, {\n      # only execute this on complete color hex codes\n      if (grepl(\"^#[0123456789ABCDEFabcdef]{6}$\", input$hexcolor)) {\n          col_RGB <- colorspace::hex2RGB(input$hexcolor)\n          coords_HCL <- colorspace::coords(as(col_RGB, \"polarLUV\"))\n          updateSliderInput(session, \"L\", value = round(coords_HCL[1L]))\n          updateSliderInput(session, \"C\", value = round(coords_HCL[2L]))\n          updateSliderInput(session, \"H\", value = round(coords_HCL[3L]))\n      }\n    })\n\n\n    # ----------------------------------------------------------------\n    # save color code\n    # ----------------------------------------------------------------\n    observeEvent(input$color_picker, {\n        # cannot rely on hex color in text-input field, so recalculate from set H, C, L values\n        hexcolor <- colorspace::hex(colorspace::polarLUV(as.numeric(input$L), as.numeric(input$C), as.numeric(input$H)))\n        # only add color if it's not already in the list\n        if ( ! is.na(hexcolor) && ! hexcolor %in% picked_color_list$cl) {\n            picked_color_list$cl <- c(picked_color_list$cl, hexcolor)\n        } else {\n            showNotification(\"No valid color selected.\")\n        }\n        if ( length(picked_color_list$cl) == 0 ) return()\n        generateExport(output, picked_color_list$cl) \n    })\n\n    # ----------------------------------------------------------------\n    # undo pick color\n    # ----------------------------------------------------------------\n    observeEvent(input$color_unpicker, {\n        if (input$hexcolor %in% picked_color_list$cl)\n            picked_color_list$cl <- picked_color_list$cl[picked_color_list$cl != input$hexcolor]\n        #} else {\n        #  # It's a better user interface to leave the list alone if the color is not in the list\n        #  # picked_color_list$cl <- head(picked_color_list$cl,-1)\n        #}\n    })\n\n    # ----------------------------------------------------------------\n    # clear saved color code\n    # ----------------------------------------------------------------\n    observeEvent(input$clear_color_picker, {\n        picked_color_list$cl <- c()\n    })\n\n    # ----------------------------------------------------------------\n    # ----------------------------------------------------------------\n    observe({\n        updateTextInput(session, \"hexcolor\",\n                               value = colorspace::hex(colorspace::polarLUV(as.numeric(input$L),\n                                                    as.numeric(input$C),\n                                                    as.numeric(input$H))))\n    })\n\n    # ----------------------------------------------------------------\n    # ----------------------------------------------------------------\n    output$colorbox <- renderUI({\n        tags$div(style=paste0(\"width: 100%; height: 40px; \",\n                                     \"border: 1px solid rgba(0, 0, 0, .2); background: \",\n                     colorspace::hex(colorspace::polarLUV(as.numeric(input$L),\n                                  as.numeric(input$C),\n                                  as.numeric(input$H))), \";\"))\n    })\n\n    # generate HC plot with given inputs\n    output$HC_plot <- renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_hue_chroma_plot(as.numeric(input$L),\n                                     as.numeric(input$C),\n                                     as.numeric(input$H))\n    })\n\n    # generate LC plot with given inputs\n    output$LC_plot <- renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_luminance_chroma_plot(as.numeric(input$L),\n                                           as.numeric(input$C),\n                                           as.numeric(input$H))\n    })\n\n\n    output$Hgrad <- renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_H_gradient(as.numeric(input$L),\n                                as.numeric(input$C),\n                                as.numeric(input$H))\n    })\n\n    output$Hgrad2 <- renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_H_gradient(as.numeric(input$L),\n                                as.numeric(input$C),\n                                as.numeric(input$H))\n    })\n\n    output$Cgrad <- renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_C_gradient(as.numeric(input$L),\n                                as.numeric(input$C),\n                                as.numeric(input$H))\n    })\n\n    output$Cgrad2 <- renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_C_gradient(as.numeric(input$L),\n                                as.numeric(input$C),\n                                as.numeric(input$H))\n    })\n\n\n    output$Lgrad <- renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_L_gradient(as.numeric(input$L),\n                                as.numeric(input$C),\n                                as.numeric(input$H))\n    })\n\n    output$Lgrad2 <- renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        color_picker_L_gradient(as.numeric(input$L),\n                                as.numeric(input$C),\n                                as.numeric(input$H))\n    })\n\n    # generate palette plot with given hex code\n    output$palette_plot <- renderPlot({\n        par(bg       = ifelse(input$darkmode, \"black\", \"white\"),\n            fg       = ifelse(input$darkmode, \"white\", \"black\"),\n            col.axis = ifelse(input$darkmode, \"white\", \"black\"))\n        pal_plot(picked_color_list$cl)\n    })\n\n    # add R color code line\n    output$palette_line_R <- renderText({\n        if (length(picked_color_list$cl) != 0) {\n            color_list  <- picked_color_list$cl\n            color_list  <- paste(color_list, collapse = \"', '\")\n            color_string <- paste(\"<code>colors <- c('\", color_list, \"')<\/code>\", sep = '')\n            sprintf(\"<b style=\\\"display:block;margin-top:5px\\\">R style color vector<\/b>%s\", color_string)\n        } else {\n            paste(\"Currently no colors picked. Go to the \\\"<b>Luminance-Chroma plane<\/b>\\\"\",\n                  \"or the \\\"<b>Hue-Chroma plane<\/b>\\\" tab, define a color,\",\n                  \"and press <b>pick<\/b> to add the color to your selection.\")\n        }\n    })\n    # Add matlab style output\n    output$palette_line_matlab <- renderText({\n        if (length(picked_color_list$cl) != 0){\n            # Convert colors to RGB for matlab\n            color_string <- sprintf(\"<code>colors = [%s]<\/code>\",\n                   paste0(apply(colorspace::hex2RGB(picked_color_list$cl)@coords,1, function(x)\n                   sprintf(\"%.3f,%.3f,%.3f\",x[1L],x[2L],x[3L])),collapse=\"; \"))\n            sprintf(\"<b style=\\\"display:block;margin-top:5px\\\">matlab style color vector<\/b>%s\", color_string)\n        }\n    })\n\n    # ----------------------------------------------------------------\n    # Version information lower right corner\n    # ----------------------------------------------------------------\n    output$version_info <- renderText(sprintf(\"<a href=\\\"%s\\\">R colorspace 2.1-1<\/a>\",\n                                      \"https://cran.r-project.org/package=colorspace\"))\n\n\n\n    # downloadHandler() takes two arguments, both functions.\n    # The content function is passed a filename as an argument, and\n    #   it should write out data to that filename.\n    getRGB <- function(int=FALSE) {\n        colors <- picked_color_list$cl\n        if ( int ) { scale = 255; digits = 0 } else { scale = 1; digits = 3 }\n        RGB <- round(attr(colorspace::hex2RGB(colors), \"coords\")*scale, digits)\n        return(RGB)\n    }\n    getHCL <- function() {\n        HCL <- colorspace::coords(as(colorspace::hex2RGB(picked_color_list$cl), \"polarLUV\"))\n        HCL <- round(HCL)[,c(\"H\",\"C\",\"L\")]\n        if ( is.null(nrow(HCL)) ) HCL <- as.matrix(t(HCL))\n        return(HCL)\n    }\n    output$downloadRAW1 <- downloadHandler(\n        file <- \"colormap_HCL.txt\",\n        content = function(file) {\n            if ( length(picked_color_list$cl) > 0 ) {\n                write.table(getHCL(),  file,  sep = \",\",\n                            col.names = TRUE,  row.names = FALSE)\n            } else {\n                write(file = file, \"No colors selected.\")\n            }\n        }\n    )\n    output$downloadRAW2 <- downloadHandler(\n        file <- \"colormap_RGB.txt\",\n        content = function(file) {\n            if ( length(picked_color_list$cl) > 0 ) {\n                write.table(getRGB(TRUE),  file,  sep = \",\", \n                            col.names = TRUE,  row.names = FALSE)\n            } else {\n                write(file = file, \"No colors selected.\")\n            }\n        }\n    )\n    output$downloadRAW3 <- downloadHandler(\n        file <- \"colormap_hex.txt\",\n        content = function(file) {\n            if ( length(picked_color_list$cl) > 0 ) {\n                write.table(picked_color_list$cl,  file,  sep = \",\", \n                            col.names = FALSE, row.names = FALSE)\n            } else {\n                write(file = file, \"No colors selected.\")\n            }\n        }\n    )\n\n})\n\n\ncolor_picker_hue_chroma_plot <- function(L = 75, C = 20, H = 0, n = 200) {\n\n    Cmax  <- max(colorspace::max_chroma(0:360, L))\n    Vmax  <- Cmax\n    Umax  <- Cmax\n    U     <- seq(-Umax, Umax, length.out = n)\n    V     <- seq(Vmax, -Vmax, length.out = n)\n    grid  <- expand.grid(U = U, V = V)\n    image <- matrix(colorspace::hex(colorspace::LUV(L, grid$U, grid$V)), nrow = n, byrow = TRUE)\n    grob  <- grid::rasterGrob(image)\n\n    sel_col <- colorspace::polarLUV(L, C, H) # selected color in polar LUV\n    sel_pt  <- colorspace::coords(as(sel_col, \"LUV\")) # coordinates of selected point in LUV\n    df_sel  <- data.frame(U = sel_pt[2L], V = sel_pt[3L])\n\n    grid$hex <- as.vector(t(image))\n    limits   <- lapply(na.omit(grid), function(x)\n                if ( ! is.numeric(x) ) { return(NULL) } else { max(abs(x))*c(-1,1) } )\n    par(mar = c(3, 3, 1, 1))\n    with(grid, graphics::plot(V ~ U, type=\"n\", bty = \"n\", axes = FALSE,\n                              xaxs = \"i\", yaxs = \"i\", asp = 1, xlim=limits$U, ylim=limits$V))\n    graphics::abline(h = seq(-200,200,by=25), v = seq(-200,200,by=25), col = \"gray80\")\n    graphics::axis(side = 1, at = seq(-200,200,by=50), col = NA, col.ticks = 1)\n    graphics::axis(side = 2, at = seq(-200,200,by=50), col = NA, col.ticks = 1)\n    graphics::points(grid$V ~ grid$U, col = grid$hex, pch = 19)\n\n    # Selected color\n    graphics::points(sel_pt[1,\"V\"] ~ sel_pt[1,\"U\"], cex = 2)\n    sel_radius <- sqrt(sum(sel_pt[1, c(\"U\", \"V\")]^2))\n    graphics::lines(sin(seq(0, 2 * pi, length.out = 300)) * sel_radius,\n                    cos(seq(0, 2 * pi, length.out = 300)) * sel_radius, col = \"gray40\")\n\n    # Box\n    graphics::box(col = \"gray40\")\n\n}\n\ncolor_picker_luminance_chroma_plot <- function(L = 75, C = 20, H = 0, n = 200) {\n\n    Cmax    <- max(C + 5, 150)\n    Cseq    <- seq(0, Cmax, length.out = n)\n    Lseq    <- seq(100, 0, length.out = n)\n    grid    <- expand.grid(C = Cseq, L = Lseq)\n    # Remove points with L == 0 & C > 0\n    grid[which(grid$L == 0 & grid$C > 0),] <- NA\n    image   <- matrix(colorspace::hex(colorspace::polarLUV(grid$L, grid$C, H)), nrow = n, byrow = TRUE)\n    grob    <- grid::rasterGrob(image, width = 1, height = 1)\n\n    sel_col <- colorspace::polarLUV(L, C, H) # selected color in polar LUV\n    df_sel  <- data.frame(C = C, L = L)\n\n    grid$hex <- as.vector(t(image))\n    limits   <- with(na.omit(grid), list( L = c(0,100), C = c(0,max(C))))\n    par( mar = c(3, 3, 1, 1) )\n    with( grid, graphics::plot(L ~ C, type=\"n\", bty = \"n\", axes = FALSE,\n                               asp = 1, xaxs = \"i\", yaxs = \"i\", xlim=limits$C, ylim=limits$L))\n    graphics::abline(h = seq(-200,200,by=25), v = seq(-200,200,by=25), col = \"gray80\")\n    graphics::axis(side = 1, at = seq(limits$C[1L],limits$C[2L],by=25), col = NA, col.ticks = 1)\n    graphics::axis(side = 2, at = seq(limits$L[1L],limits$L[2L],by=25), col = NA, col.ticks = 1)\n    graphics::points(grid$L ~ grid$C, col = grid$hex, pch = 19 )\n    # Selected color\n    graphics::points(df_sel[1,\"L\"] ~ df_sel[1,\"C\"], cex = 2)\n    # Box\n    graphics::box(col = \"gray40\")\n\n}\n\n# Helper function to draw the color bar (gradient's).\n# Input \\code{seq} has to be numeric, sequence of values\n# along the color bar dimension. Cols is an object of\n# NA's and hex colors which can be converted to a vector.\n# Typically a matrix. Length of \\code{cols} has to be equal to\n# length of \\code{seq}.\nplot_color_gradient <- function( seq, cols, sel, ylab = NA, ticks ) {\n\n    par(mar = c(2, 2, .1, 1))\n    # Compute args\n    dx   <- 0.5 * median(diff(seq))\n    seq  <- seq(min(seq), max(seq), length.out=length(cols))\n    args <- list(ybottom = rep(0,length(cols)), ytop = rep(1,length(cols)))\n    args$xleft <- seq - dx;          args$xright <- seq + dx\n    args$col   <- as.vector(cols);   args$border <- NA\n    # Create color bar\n    graphics::plot(NA, ylim = c(0, 1), xlim = range(seq), xaxs = \"i\", yaxs = \"i\",\n                   xlab = NA, ylab = NA, bty = \"n\", axes = FALSE)\n    do.call(\"rect\", args)\n    if ( ! is.na(ylab) )   graphics::mtext(side = 2, line = 0.5, ylab, las = 2)\n    if ( missing(ticks)  ) ticks <- pretty(seq)\n    graphics::points(sel, 0.5, cex = 2)\n    graphics::axis(side = 1, at = ticks, col = NA, col.ticks = 1)\n    graphics::box(col = \"gray40\")\n\n}\n\ncolor_picker_C_gradient <- function(L = 75, C = 20, H = 0, n = 100) {\n\n    Cmax    <- max(C + 5, 150)\n    Cseq    <- seq(0, Cmax, length.out = n)\n    image   <- matrix(colorspace::hex(colorspace::polarLUV(L, Cseq, H)), nrow = 1, byrow = TRUE)\n    grob    <- grid::rasterGrob(image, width = 1, height = 1)\n\n    sel_col <- colorspace::hex(colorspace::polarLUV(L, C, H))\n    df_sel  <- data.frame(C = C, H = H, L = L, y = 0)\n\n    # Craw color gradient/color bar\n    plot_color_gradient(Cseq, image, df_sel$C, \"C\")\n\n}\n\ncolor_picker_H_gradient <- function(L = 75, C = 20, H = 0, n = 100) {\n\n    Hseq = seq(0, 360, length.out = n)\n    image <- matrix(colorspace::hex(colorspace::polarLUV(L, C, Hseq)), nrow = 1, byrow = TRUE)\n    grob <- grid::rasterGrob(image, width = 1, height = 1)\n\n    sel_col <- colorspace::hex(colorspace::polarLUV(L, C, H))\n    df_sel <- data.frame(C = C, H = H, L = L, y = 0)\n\n    # Craw color gradient/color bar\n    plot_color_gradient(Hseq, image, df_sel$H, \"H\", seq(0,360,by=45))\n}\n\ncolor_picker_L_gradient <- function(L = 75, C = 20, H = 0, n = 100) {\n\n    Lseq = seq(0, 100, length.out = n)\n    image <- matrix(colorspace::hex(colorspace::polarLUV(Lseq, C, H)), nrow = 1, byrow = TRUE)\n    if ( C > 0 ) image[1,1] <- \"#ffffff\"\n    grob <- grid::rasterGrob(image, width = 1, height = 1)\n\n    sel_col <- colorspace::hex(colorspace::polarLUV(L, C, H))\n    df_sel <- data.frame(C = C, H = H, L = L, y = 0)\n\n    # Craw color gradient/color bar\n    plot_color_gradient(Lseq, image, df_sel$L, \"L\")\n}\n\npal_plot <- function(colors) {\n\n    # Base plot\n    graphics::par(mai = rep(0,4), mar = rep(0,4))\n    graphics::plot(0, 0, type = \"n\", xlim = c(0, 1), ylim = c(0, 1),\n                   xaxs = \"i\", yaxs = \"i\", axes = FALSE, xlab = \"\", ylab=\"\")\n\n    # convert colors to hex and find luminance for each\n    n <- length(colors)\n    if ( n == 0 ) {\n        text(0, 0.5, pos = 4, col = \"#BFBEBD\", \"No colors selected\")\n    } else {\n        col      <- colorspace::hex2RGB(colors)\n        # Convert to HCL to define the text color\n        HCL <- as(colorspace::hex2RGB(colors), \"polarLUV\")\n        text_col <- cursor_color(HCL@coords[, 1L])\n        # Calculate rectangle width/position\n        if ( n == 1 ) {\n            w = 1; x = 0\n        } else {\n            w <- 0.95 / n\n            x <- seq(0, 1, by = w + 0.05 / (n - 1))\n        }\n        graphics::rect(x, 0, x + w, 1, col = colors, border = NA)\n        graphics::text(x + w / 2., .5, labels = colors, col = text_col, cex = 1.2)\n        #graphics::rect((0:(n-1)+.1)/n, 0, (1:n-.1)/n, 1, col = colors, border = NA)\n        #graphics::text((0:(n-1)+.5)/n, .5, labels = colors, col = text_col, cex = 1.2)\n    }\n\n}\n\ncursor_color <- function(L) ifelse(L >= 50, \"#000000\", \"#FFFFFF\")\n\n# ----------------------------------------------------------------\n# Export colors: generate export content\n# ----------------------------------------------------------------\ngenerateExport <- function(output, colors) {\n\n   # Setting \"NA\" colors if fixup=FALSE to white and\n   # store the indizes on colors.na. Replacement required\n   # to be able to convert hex->RGB, index required to\n   # create proper output (where NA values should be displayed).\n   colors.na <- which(is.na(colors))\n   colors[is.na(colors)] <- \"#ffffff\"\n\n   # --------------------------\n   # RAW\n   # --------------------------\n   # Generate RGB coordinates\n   sRGB <- colorspace::hex2RGB(colors)\n   RGB  <- attr( sRGB, \"coords\" )\n   HCL  <- round(attr( as( sRGB, \"polarLUV\" ), \"coords\" ))\n\n   # Generate output string\n   append <- function(x,new) c(x,new)\n   raw1 <- raw2 <- raw3 <- raw4 <- list()\n   # RGB 0-1\n   raw1 <- append(raw1, \"<div style=\\\"clear: both;\\\">\")\n   raw1 <- append(raw1, \"<span class=\\\"output-raw\\\">\")\n   raw1 <- append(raw1, \"HCL values\")\n   for ( i in 1:nrow(HCL) )\n      raw1 <- append(raw1,ifelse(i %in% colors.na,\n                     gsub(\" \", \"&nbsp;\", sprintf(\"<code>%5s %5s %5s<\/code>\", \"NA\", \"NA\", \"NA\")),\n                     gsub(\" \", \"&nbsp;\", sprintf(\"<code>%4d %4d %4d<\/code>\", HCL[i,\"H\"], HCL[i,\"C\"], HCL[i,\"L\"]))))\n   raw1 <- append(raw1, \"<\/span>\")\n   # RGB 0-255\n   raw2 <- append(raw2, \"<span class=\\\"output-raw\\\">\")\n   raw2 <- append(raw2, \"RGB values [0-255]\")\n   RGB  <- round(RGB * 255)\n   for ( i in 1:nrow(RGB) )\n      raw2 <- append(raw2,ifelse(i %in% colors.na,\n                     gsub(\" \", \"&nbsp;\", sprintf(\"<code>%4s %4s %4s<\/code>\", \"NA\", \"NA\", \"NA\")),\n                     gsub(\" \", \"&nbsp;\", sprintf(\"<code>%4d %4d %4d<\/code>\", RGB[i,1], RGB[i,2], RGB[i,3]))))\n   raw2 <- append(raw2,\"<\/span>\")\n   # HEX colors\n   raw3 <- append(raw3,\"<span class=\\\"output-raw\\\">\")\n   raw3 <- append(raw3,\"HEX colors, no alpha\")\n   for ( i in seq_along(colors) )\n      raw3 <- append(raw3,ifelse(i %in% colors.na,\n                     gsub(\" \",\"&nbsp;\",sprintf(\"<code>%7s<\/code>\",\"NA\")),\n                     sprintf(\"<code>%s<\/code>\",colors[i])))\n   raw3 <- append(raw3, \"<\/span>\")\n   # Color boxes (visual bar) \n   raw4 <- append(raw4, \"<span class=\\\"output-raw\\\">\")\n   raw4 <- append(raw4, \"Color Map\")\n   for ( col in colors )\n      raw4 <- append(raw4, sprintf(\"<cbox style='background-color: %s'><\/cbox>\", col))\n   raw4 <- append(raw4, \"<\/span>\")\n   raw4 <- append(raw4, \"<\/div>\")\n\n   output$exportRAW1 <- renderText(paste(raw1, collapse = \"\\n\"))\n   output$exportRAW2 <- renderText(paste(raw2, collapse = \"\\n\"))\n   output$exportRAW3 <- renderText(paste(raw3, collapse = \"\\n\"))\n   output$exportRAW4 <- renderText(paste(raw4, collapse = \"\\n\"))\n\n   \n   # -----------------------------\n   # For GrADS\n   # -----------------------------\n   gastr <- c()\n   gastr <- append(gastr, \"<div class=\\\"output-grads\\\">\")\n   gastr <- append(gastr, \"<comment>** Define colors palette<\/comment>\") \n   if ( length(colors.na) > 0 )\n      gastr <- append(gastr, \"<comment>** WARNING undefined colors in color map!<\/comment>\") \n   for ( i in 1:nrow(RGB) ) {\n      gastr <- append(gastr,ifelse(i %in% colors.na,\n                      gsub(\" \", \"&nbsp;\",sprintf(\"<code>'set rgb %02d %4s %4s %4s'<\/code>\",\n                                           i + 19, \"NA\", \"NA\", \"NA\")),\n                      gsub(\" \", \"&nbsp;\",sprintf(\"<code>'set rgb %02d %4d %4d %4d'<\/code>\",\n                                           i + 19, RGB[i,1], RGB[i,2], RGB[i,3]))))\n   }\n   gastr <- append(gastr, sprintf(\"<code>'set ccols %s'<\/code>\",\n                                  paste(1:nrow(RGB) + 19, collapse = \" \")))\n   gastr <- append(gastr, sprintf(\"<code>'set clevs %s'<\/code>\",\n                                  paste(round(seq(0, 100, length.out=nrow(RGB) - 1), 1), collapse=\" \")))\n   gastr <- append(gastr, \"<comment>** Open data set via DODS<\/comment>\")\n   gastr <- append(gastr, \"<comment>** Open data set via DODS<\/comment>\")\n   gastr <- append(gastr, strftime(Sys.Date() - 1, \"<code>'sdfopen http://nomads.ncep.noaa.gov:9090/dods/gfs_1p00/gfs%Y%m%d/gfs_1p00_00z_anl'<\/code>\"))\n   output$exportGrADS <- renderText(paste(gastr, collapse = \"\\n\"))\n\n   # -----------------------------\n   # For Python\n   # -----------------------------\n   pystr <- c()\n   pystr <- append(pystr, \"<div class=\\\"output-python\\\">\")\n   pystr <- append(pystr, \"<comment>## Define choosen color palette first<\/comment>\") \n   pystr <- append(pystr, \"<comment>## WARNING undefined colors in color map!<\/comment>\") \n   pycolors <- sprintf(\"\\\"%s\\\"\", colors)\n   if ( length(colors.na) > 0 ) pycolors[colors.na] <- \"None\"\n   pystr <- append(pystr, sprintf(\"<code>colors = (%s)<\/code>\",\n                   paste(sprintf(\"%s\", pycolors), collapse = \",\")))\n   pystr <- append(pystr, \"<\/div>\")\n\n   output$exportPython <- renderText(paste(pystr, collapse = \"\\n\"))\n\n   # -----------------------------\n   # For Matlab\n   # -----------------------------\n   RGB  <- attr(colorspace::hex2RGB(colors),\"coords\")\n   mstr <- c()\n   mstr <- append(mstr, \"<div class=\\\"output-matlab\\\">\")\n   mstr <- append(mstr, \"<comment>%% Define rgb matrix first (matrix size ncolors x 3)<\/comment>\")\n   if ( length(colors.na) > 0 )\n      mstr <- append(mstr, \"<comment>%% WARNING undefined colors in color map!<\/comment>\")\n   vardef <- \"colors = [\"\n   for ( i in 1:nrow(RGB) ) {\n      if ( i == 1 )             { pre <- vardef; post <- \";\" }\n      else if ( i < nrow(RGB) ) { pre <- paste(rep(\" \", nchar(vardef)), collapse = \"\"); post <- \";\" }\n      else                      { pre <- paste(rep(\" \", nchar(vardef)), collapse = \"\"); post <- \"]\" }\n      if ( i %in% colors.na ) {\n         tmp <- sprintf(\"<code>%s%5s,%5s,%5s%s<\/code>\",\n                        pre, \"NaN\", \"NaN\", \"NaN\", post)\n      } else {\n         tmp <- sprintf(\"<code>%s%5.3f,%5.3f,%5.3f%s<\/code>\",\n                        pre, RGB[i, 1], RGB[i, 2], RGB[i, 3], post)\n      }\n      mstr <- append(mstr, gsub(\" \", \"&nbsp;\", tmp))\n   }\n   mstr <- append(mstr, \"<\/div>\")\n\n   output$exportMatlab <- renderText(paste(mstr, collapse=\"\\n\"))\n\n}\n\nshinyApp(ui, server)\n\n","type":"text"},{"name":"LICENSE.md","content":"YEAR: 2005-2025\nCOPYRIGHT HOLDER: Ross Ihaka, Paul Murrell, Kurt Hornik, Jason C. Fisher, Reto Stauffer, Claus O. Wilke, Claire D. McWhite, Achim Zeileis\nORGANIZATION: Ross Ihaka, Paul Murrell, Kurt Hornik, Jason C. Fisher, Reto Stauffer, Claus O. Wilke, Claire D. McWhite, Achim Zeileis\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n    Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in\n    the documentation and/or other materials provided with the\n    distribution.\n\n    Neither the name of the <ORGANIZATION> nor the names of its\n    contributors may be used to endorse or promote products derived\n    from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n","type":"text"},{"name":"README.md","content":"## README\n\nThe color-chooser app was copied from the colorspace package (version 2.1-1) and lightly modified to work better as a standalone website. The app is provided under its original license (BSD 3 clause), see LICENSE.md.","type":"text"},{"name":"hclcolorpicker.css","content":"/* Export tab styling */\nbody {\n    padding-top: 1em;\n}\ndiv#hcl-export div.output-raw  {\n    width: 25%;\n    height: 100%;\n    float: left;\n    min-width: 150px;\n    padding-bottom: 30px;\n}\ndiv#hcl-export div.output-raw a.shiny-download-link {\n    margin-top: 30px;\n}\ndiv#hcl-export comment {\n    font-family: Menlo,Monaco,Consolas,\"Courier New\",monospace;\n    background-color: white;\n    color: #337ab7;\n    display: block;\n}\ndiv.output-raw code {\n    background-color: white;\n    color: black;\n    display: block;\n}\ndiv#hcl-export span.output-raw cbox {\n    display: block;\n    width: 100%;\n    height: 22px;\n}\ndiv.end-float {\n    float: none;\n    clear: both;\n}\ndiv.output-raw {\n    padding-top: 1em;\n}\n/* Package information */\nbody { padding-bottom: 10px; }\ndiv.version-info {\n    position: fixed;\n    right: 0;\n    bottom: 0;\n    font-size: .8em;\n    padding: 2px 5px;\n}\ndiv.version-info a {\n    color: #BFBEBD;\n}\ndiv.version-info a:hover {\n    text-decoration: underline;\n    color: #BFBEBD;\n}\n","type":"text"},{"name":"hclcolorpicker_darkmode.css","content":"\n\nbody.darkmode {\n    background-color: black;\n    color: white;\n}\n\n.darkmode .well {\n    background-color: #181818;\n    color: #D0D0D0;\n    border-color: #3277b3;\n}\n\n.darkmode .nav-tabs > li.active > a,\n.darkmode .nav-tabs > li.active > a:focus,\n.darkmode .nav-tabs > li.active > a:hover {\n    background: black;\n    color: #D0D0D0;\n}\n.darkmode .nav-tabs > li > a:hover {\n    background: black;\n    color: #88b5dd;\n}\n.darkmode .nav-tabs > li.active > a:hover {\n    background: #181818;\n    color: #F0F0F0;\n}\n\n.darkmode div#hcl-export code {\n    background-color: black;\n    color: white;\n}\n\n.darkmode div#hcl-export comment {\n    background-color: black;\n    color: #88b5dd;\n}\n\n.darkmode .selectize-input.full {\n    /* background: #282828; */\n    background: black;\n    color: white;\n}\n.darkmode .selectize-input,\n.darkmode .selectize-control.single .selectize-input.input-active {\n    /* background: #282828; */\n    background: black;\n}\n\n.darkmode .selectize-dropdown {\n    color: #808080;\n}\n.darkmode .selectize-dropdown .active {\n    background-color: black;\n    color: #88b5dd;\n}\n\n.darkmode .selectize-dropdown,\n.darkmode .selectize-dropdown.form-control {\n    background: black;\n}\n\n.darkmode .btn-default {\n    background-color: #181818;\n    color: #F0F0F0;\n}\n.darkmode .btn-default:hover {\n    background: #282828;\n    color: #88b5dd;\n}\n\n.darkmode .irs-min,\n.darkmode .irs-max {\n    background: #282828;\n    color: white;\n}\n\n.darkmode .irs-line-left,\n.darkmode .irs-line-mid,\n.darkmode .irs-line-right {\n    background-color: black;\n}\n.darkmode .irs-line {\n    border-color: #505050;\n}\n.darkmode .irs-slider {\n    background-color: black;\n}\n.darkmode .form-control {\n    background-color: black;\n    color: white;\n}\n.darkmode code {\n    background: #282828;\n    color: #88b5dd;\n    font-weight: bold;\n}\n","type":"text"},{"name":"info.html","content":"<h3>Graphical User Interface to Pick Colors in HCL Space<\/h3>\n\n<p>Claus O. Wilke, Reto Stauffer, Achim Zeileis<\/p>\n\n<p>The app visualizes colors either along the hue-chroma plane for a given luminance value or along the\nluminance-chroma plane for a given hue. Colors can be entered by specifying the hue (H), chroma (C),\nand luminance (L) values via sliders, by entering an RGB hex code, or by clicking on a color in the\nhue-chroma or luminance-chroma plane. It is also possible to select individual colors and add them\nto a palette for comparison and future reference.\n<\/p>\n","type":"text"}]
